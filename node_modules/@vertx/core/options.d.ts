/*
 * Copyright 2020 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

/** Auto-generated from public abstract interface io.vertx.core.net.KeyCertOptions extends 
 */
export interface KeyCertOptions {

  /** Auto-generated from io.vertx.core.net.KeyCertOptions#copy
   */
  copy() : KeyCertOptions;

  /** Auto-generated from io.vertx.core.net.KeyCertOptions#getKeyManagerFactory
   * @throws java.lang.Exception
   */
  getKeyManagerFactory(arg0: /* io.vertx.core.Vertx */ any) : /* javax.net.ssl.KeyManagerFactory */ any;

  /** Auto-generated from io.vertx.core.net.KeyCertOptions#keyManagerMapper
   * @throws java.lang.Exception
   */
  keyManagerMapper(arg0: /* io.vertx.core.Vertx */ any) : /* java.util.function.Function<java.lang.String, javax.net.ssl.X509KeyManager> */ any;

}

/** Auto-generated from public abstract io.vertx.core.net.SSLEngineOptions extends java.lang.Object
 */
export abstract class SSLEngineOptions {

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#io.vertx.core.net.SSLEngineOptions
   */
  constructor();

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#copy
   */
  copy() : SSLEngineOptions;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#wait
   * @throws java.lang.InterruptedException
   */
  wait(arg0: number, arg1: number) : void;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#wait
   * @throws java.lang.InterruptedException
   */
  wait(arg0: number) : void;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#wait
   * @throws java.lang.InterruptedException
   */
  wait() : void;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#equals
   */
  equals(arg0: any) : boolean;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#toString
   */
  toString() : string;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#hashCode
   */
  hashCode() : number;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#getClass
   */
  getClass() : /* java.lang.Class<?> */ any;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#notify
   */
  notify() : void;

  /** Auto-generated from io.vertx.core.net.SSLEngineOptions#notifyAll
   */
  notifyAll() : void;

}

/** Auto-generated from public abstract interface io.vertx.core.net.TrustOptions extends 
 */
export interface TrustOptions {

  /** Auto-generated from io.vertx.core.net.TrustOptions#copy
   */
  copy() : TrustOptions;

  /** Auto-generated from io.vertx.core.net.TrustOptions#getTrustManagerFactory
   * @throws java.lang.Exception
   */
  getTrustManagerFactory(arg0: /* io.vertx.core.Vertx */ any) : /* javax.net.ssl.TrustManagerFactory */ any;

  /** Auto-generated from io.vertx.core.net.TrustOptions#trustManagerMapper
   * @throws java.lang.Exception
   */
  trustManagerMapper(arg0: /* io.vertx.core.Vertx */ any) : /* java.util.function.Function<java.lang.String, javax.net.ssl.TrustManager[]> */ any;

}

import { Buffer } from './index';

/**
 * Configuration options for Vert.x hostname resolver. The resolver uses the local <i>hosts</i> file and performs
 * DNS <i>A</i> and <i>AAAA</i> queries.
 */
export class AddressResolverOptions {

  constructor();

  constructor(obj: AddressResolverOptions);

  /**
   * Set the cache maximum TTL value in seconds. After successful resolution IP addresses are cached with their DNS response TTL,
   * use this to set a maximum value to all responses TTL.
   */
  getCacheMaxTimeToLive(): number;

  /**
   * Set the cache maximum TTL value in seconds. After successful resolution IP addresses are cached with their DNS response TTL,
   * use this to set a maximum value to all responses TTL.
   */
  setCacheMaxTimeToLive(cacheMaxTimeToLive: number): AddressResolverOptions;

  /**
   * Set the cache minimum TTL value in seconds. After resolution successful IP addresses are cached with their DNS response TTL,
   * use this to set a minimum value to all responses TTL.
   */
  getCacheMinTimeToLive(): number;

  /**
   * Set the cache minimum TTL value in seconds. After resolution successful IP addresses are cached with their DNS response TTL,
   * use this to set a minimum value to all responses TTL.
   */
  setCacheMinTimeToLive(cacheMinTimeToLive: number): AddressResolverOptions;

  /**
   * Set the negative cache TTL value in seconds. After a failed hostname resolution, DNS queries won't be retried
   * for a period of time equals to the negative TTL. This allows to reduce the response time of negative replies
   * and reduce the amount of messages to DNS servers.
   */
  getCacheNegativeTimeToLive(): number;

  /**
   * Set the negative cache TTL value in seconds. After a failed hostname resolution, DNS queries won't be retried
   * for a period of time equals to the negative TTL. This allows to reduce the response time of negative replies
   * and reduce the amount of messages to DNS servers.
   */
  setCacheNegativeTimeToLive(cacheNegativeTimeToLive: number): AddressResolverOptions;

  /**
   * Set the path of an alternate hosts configuration file to use instead of the one provided by the os.
   * <p/>
   * The default value is null, so the operating system hosts config is used.
   */
  getHostsPath(): string;

  /**
   * Set the path of an alternate hosts configuration file to use instead of the one provided by the os.
   * <p/>
   * The default value is null, so the operating system hosts config is used.
   */
  setHostsPath(hostsPath: string): AddressResolverOptions;

  /**
   * Set an alternate hosts configuration file to use instead of the one provided by the os.
   * <p/>
   * The value should contain the hosts content literaly, for instance <i>127.0.0.1 localhost</i>
   * <p/>
   * The default value is null, so the operating system hosts config is used.
   */
  getHostsValue(): Buffer;

  /**
   * Set an alternate hosts configuration file to use instead of the one provided by the os.
   * <p/>
   * The value should contain the hosts content literaly, for instance <i>127.0.0.1 localhost</i>
   * <p/>
   * The default value is null, so the operating system hosts config is used.
   */
  setHostsValue(hostsValue: Buffer): AddressResolverOptions;

  /**
   * Set the maximum number of queries when an hostname is resolved.
   */
  getMaxQueries(): number;

  /**
   * Set the maximum number of queries when an hostname is resolved.
   */
  setMaxQueries(maxQueries: number): AddressResolverOptions;

  /**
   * Set the ndots value used when resolving using search domains, the default value is <code>-1</code> which
   * determines the value from the OS on Linux or uses the value <code>1</code>.
   */
  getNdots(): number;

  /**
   * Set the ndots value used when resolving using search domains, the default value is <code>-1</code> which
   * determines the value from the OS on Linux or uses the value <code>1</code>.
   */
  setNdots(ndots: number): AddressResolverOptions;

  /**
   * Set to true to enable the automatic inclusion in DNS queries of an optional record that hints
   * the remote DNS server about how much data the resolver can read per response.
   */
  isOptResourceEnabled(): boolean;

  /**
   * Set to true to enable the automatic inclusion in DNS queries of an optional record that hints
   * the remote DNS server about how much data the resolver can read per response.
   */
  setOptResourceEnabled(optResourceEnabled: boolean): AddressResolverOptions;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   */
  getQueryTimeout(): number;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   */
  setQueryTimeout(queryTimeout: number): AddressResolverOptions;

  /**
   * Set the DNS queries <i>Recursion Desired</i> flag value.
   */
  getRdFlag(): boolean;

  /**
   * Set the DNS queries <i>Recursion Desired</i> flag value.
   */
  setRdFlag(rdFlag: boolean): AddressResolverOptions;

  /**
   * Set to <code>true</code> to enable round-robin selection of the dns server to use. It spreads the query load
   * among the servers and avoids all lookup to hit the first server of the list.
   */
  isRotateServers(): boolean;

  /**
   * Set to <code>true</code> to enable round-robin selection of the dns server to use. It spreads the query load
   * among the servers and avoids all lookup to hit the first server of the list.
   */
  setRotateServers(rotateServers: boolean): AddressResolverOptions;

  /**
   * Set the lists of DNS search domains.
   * <p/>
   * When the search domain list is null, the effective search domain list will be populated using
   * the system DNS search domains.
   */
  getSearchDomains(): string;

  /**
   * Set the lists of DNS search domains.
   * <p/>
   * When the search domain list is null, the effective search domain list will be populated using
   * the system DNS search domains.
   */
  setSearchDomains(searchDomains: string): AddressResolverOptions;

  /**
   * Set the lists of DNS search domains.
   * <p/>
   * When the search domain list is null, the effective search domain list will be populated using
   * the system DNS search domains.
   */
  addSearchDomain(searchDomains: string): AddressResolverOptions;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   * colon and a port, e.g <code>8.8.8.8</code> or {code 192.168.0.1:40000}. When the list is empty, the resolver
   * will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   * it will use Google's public DNS servers <code>"8.8.8.8"</code> and <code>"8.8.4.4"</code>.
   */
  getServers(): string;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   * colon and a port, e.g <code>8.8.8.8</code> or {code 192.168.0.1:40000}. When the list is empty, the resolver
   * will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   * it will use Google's public DNS servers <code>"8.8.8.8"</code> and <code>"8.8.4.4"</code>.
   */
  setServers(servers: string): AddressResolverOptions;

  /**
   * Set the list of DNS server addresses, an address is the IP  of the dns server, followed by an optional
   * colon and a port, e.g <code>8.8.8.8</code> or {code 192.168.0.1:40000}. When the list is empty, the resolver
   * will use the list of the system DNS server addresses from the environment, if that list cannot be retrieved
   * it will use Google's public DNS servers <code>"8.8.8.8"</code> and <code>"8.8.4.4"</code>.
   */
  addServer(servers: string): AddressResolverOptions;

}

/**
 * Defines a command line argument. Unlike options, argument don't have names and are identified using an index. The
 * first index is 0 (because we are in the computer world).
 */
export class Argument {

  constructor();

  constructor(obj: Argument);

  /**
   * Sets the argument name of this <a href="../../dataobjects.html#Argument">Argument</a>.
   */
  getArgName(): string;

  /**
   * Sets the argument name of this <a href="../../dataobjects.html#Argument">Argument</a>.
   */
  setArgName(argName: string): Argument;

  /**
   * Sets the default value of this <a href="../../dataobjects.html#Argument">Argument</a>.
   */
  getDefaultValue(): string;

  /**
   * Sets the default value of this <a href="../../dataobjects.html#Argument">Argument</a>.
   */
  setDefaultValue(defaultValue: string): Argument;

  /**
   * Sets the description of the <a href="../../dataobjects.html#Argument">Argument</a>.
   */
  getDescription(): string;

  /**
   * Sets the description of the <a href="../../dataobjects.html#Argument">Argument</a>.
   */
  setDescription(description: string): Argument;

  /**
   * Sets whether or not the current <a href="../../dataobjects.html#Argument">Argument</a> is hidden.
   */
  isHidden(): boolean;

  /**
   * Sets whether or not the current <a href="../../dataobjects.html#Argument">Argument</a> is hidden.
   */
  setHidden(hidden: boolean): Argument;

  /**
   * Sets the argument index.
   */
  getIndex(): number;

  /**
   * Sets the argument index.
   */
  setIndex(index: number): Argument;

  /**
   * Sets whether or not the argument can receive several values. Only the last argument can receive several values.
   */
  isMultiValued(): boolean;

  /**
   * Sets whether or not the argument can receive several values. Only the last argument can receive several values.
   */
  setMultiValued(multiValued: boolean): Argument;

  /**
   * Sets whether or not the current <a href="../../dataobjects.html#Argument">Argument</a> is required.
   */
  isRequired(): boolean;

  /**
   * Sets whether or not the current <a href="../../dataobjects.html#Argument">Argument</a> is required.
   */
  setRequired(required: boolean): Argument;

}


/**
 * Base class for Client options
 */
export abstract class ClientOptionsBase {

  constructor();

  constructor(obj: ClientOptionsBase);

  /**
   * Set the connect timeout
   */
  getConnectTimeout(): number;

  /**
   * Set the connect timeout
   */
  setConnectTimeout(connectTimeout: number): ClientOptionsBase;

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): ClientOptionsBase;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): ClientOptionsBase;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): ClientOptionsBase;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): ClientOptionsBase;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): ClientOptionsBase;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#ClientOptionsBase">ClientOptionsBase</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#ClientOptionsBase">ClientOptionsBase</a>
   */
  setIdleTimeout(idleTimeout: number): ClientOptionsBase;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): ClientOptionsBase;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): ClientOptionsBase;

  /**
   * Set the key/cert options.
   */
  setKeyCertOptions(keyCertOptions: KeyCertOptions): ClientOptionsBase;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): ClientOptionsBase;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   * it will pick any local address, the default local address is null.
   */
  getLocalAddress(): string;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   * it will pick any local address, the default local address is null.
   */
  setLocalAddress(localAddress: string): ClientOptionsBase;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): ClientOptionsBase;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   * with the same name.
   */
  getMetricsName(): string;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   * with the same name.
   */
  setMetricsName(metricsName: string): ClientOptionsBase;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): ClientOptionsBase;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): ClientOptionsBase;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): ClientOptionsBase;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): ClientOptionsBase;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): ClientOptionsBase;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   */
  getProxyOptions(): ProxyOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   */
  setProxyOptions(proxyOptions: ProxyOptions): ClientOptionsBase;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): ClientOptionsBase;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): ClientOptionsBase;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): ClientOptionsBase;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): ClientOptionsBase;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): ClientOptionsBase;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): ClientOptionsBase;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): ClientOptionsBase;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): ClientOptionsBase;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): ClientOptionsBase;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): ClientOptionsBase;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): ClientOptionsBase;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): ClientOptionsBase;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): ClientOptionsBase;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): ClientOptionsBase;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): ClientOptionsBase;

  /**
   * Set whether all server certificates should be trusted
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted
   */
  setTrustAll(trustAll: boolean): ClientOptionsBase;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): ClientOptionsBase;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): ClientOptionsBase;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): ClientOptionsBase;

}

/**
 * Describes the copy (and move) options.
 */
export class CopyOptions {

  constructor();

  constructor(obj: CopyOptions);

  /**
   * Whether move should be performed as an atomic filesystem operation. Defaults to <code>false</code>.
   */
  isAtomicMove(): boolean;

  /**
   * Whether move should be performed as an atomic filesystem operation. Defaults to <code>false</code>.
   */
  setAtomicMove(atomicMove: boolean): CopyOptions;

  /**
   * Whether the file attributes should be copied. Defaults to <code>false</code>.
   */
  isCopyAttributes(): boolean;

  /**
   * Whether the file attributes should be copied. Defaults to <code>false</code>.
   */
  setCopyAttributes(copyAttributes: boolean): CopyOptions;

  /**
   * Whether symbolic links should not be followed during copy or move operations. Defaults to <code>false</code>.
   */
  isNofollowLinks(): boolean;

  /**
   * Whether symbolic links should not be followed during copy or move operations. Defaults to <code>false</code>.
   */
  setNofollowLinks(nofollowLinks: boolean): CopyOptions;

  /**
   * Whether an existing file, empty directory, or link should be replaced. Defaults to <code>false</code>.
   */
  isReplaceExisting(): boolean;

  /**
   * Whether an existing file, empty directory, or link should be replaced. Defaults to <code>false</code>.
   */
  setReplaceExisting(replaceExisting: boolean): CopyOptions;

}

/**
 * Options used to configure a datagram socket.
 */
export class DatagramSocketOptions {

  constructor();

  constructor(obj: DatagramSocketOptions);

  /**
   * Set if the socket can send or receive broadcast packets
   */
  isBroadcast(): boolean;

  /**
   * Set if the socket can send or receive broadcast packets
   */
  setBroadcast(broadcast: boolean): DatagramSocketOptions;

  /**
   * Set if IP v6 should be used
   */
  isIpV6(): boolean;

  /**
   * Set if IP v6 should be used
   */
  setIpV6(ipV6: boolean): DatagramSocketOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): DatagramSocketOptions;

  /**
   * Set if loopback mode is disabled
   */
  isLoopbackModeDisabled(): boolean;

  /**
   * Set if loopback mode is disabled
   */
  setLoopbackModeDisabled(loopbackModeDisabled: boolean): DatagramSocketOptions;

  /**
   * Set the multicast network interface address
   */
  getMulticastNetworkInterface(): string;

  /**
   * Set the multicast network interface address
   */
  setMulticastNetworkInterface(multicastNetworkInterface: string): DatagramSocketOptions;

  /**
   * Set the multicast ttl value
   */
  getMulticastTimeToLive(): number;

  /**
   * Set the multicast ttl value
   */
  setMulticastTimeToLive(multicastTimeToLive: number): DatagramSocketOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): DatagramSocketOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): DatagramSocketOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): DatagramSocketOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): DatagramSocketOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): DatagramSocketOptions;

}

/**
 * Delivery options are used to configure message delivery.
 * <p>
 * Delivery options allow to configure delivery timeout and message codec name, and to provide any headers
 * that you wish to send with the message.
 */
export class DeliveryOptions {

  constructor();

  constructor(obj: DeliveryOptions);

  /**
   * Set the codec name.
   */
  getCodecName(): string;

  /**
   * Set the codec name.
   */
  setCodecName(codecName: string): DeliveryOptions;

  /**
   * Add a message header.
   * <p>
   * Message headers can be sent with any message and will be accessible with {@link Message#headers}
   * at the recipient.
   */
  addHeader(key: string, headers: string): DeliveryOptions;

  /**
   * Whether a message should be delivered to local consumers only. Defaults to <code>false</code>.
   *
   * <p>
   * <strong>This option is effective in clustered mode only and does not apply to reply messages</strong>.
   */
  isLocalOnly(): boolean;

  /**
   * Whether a message should be delivered to local consumers only. Defaults to <code>false</code>.
   *
   * <p>
   * <strong>This option is effective in clustered mode only and does not apply to reply messages</strong>.
   */
  setLocalOnly(localOnly: boolean): DeliveryOptions;

  /**
   * Set the send timeout.
   */
  getSendTimeout(): number;

  /**
   * Set the send timeout.
   */
  setSendTimeout(sendTimeout: number): DeliveryOptions;

}

/**
 * Options for configuring a verticle deployment.
 * <p>
 */
export class DeploymentOptions {

  constructor();

  constructor(obj: DeploymentOptions);

  /**
   * Set the classloader to use for deploying the Verticle.
   *
   * <p> The <code>VerticleFactory</code> will use this classloader for creating the Verticle
   * and the Verticle {@link Context} will set this classloader as context
   * classloader for the tasks execution on context.
   *
   * <p> By default no classloader is required and the deployment will use the current thread context
   * classloader.
   */
  getClassLoader(): any /* java.lang.ClassLoader */;

  /**
   * Set the classloader to use for deploying the Verticle.
   *
   * <p> The <code>VerticleFactory</code> will use this classloader for creating the Verticle
   * and the Verticle {@link Context} will set this classloader as context
   * classloader for the tasks execution on context.
   *
   * <p> By default no classloader is required and the deployment will use the current thread context
   * classloader.
   */
  setClassLoader(classLoader: any /* java.lang.ClassLoader */): DeploymentOptions;

  /**
   * Set the JSON configuration that will be passed to the verticle(s) when it's deployed
   */
  getConfig(): { [key: string]: any };

  /**
   * Set the JSON configuration that will be passed to the verticle(s) when it's deployed
   */
  setConfig(config: { [key: string]: any }): DeploymentOptions;

  /**
   * Set whether the verticle(s) will be deployed as HA.
   */
  isHa(): boolean;

  /**
   * Set whether the verticle(s) will be deployed as HA.
   */
  setHa(ha: boolean): DeploymentOptions;

  /**
   * Set the number of instances that should be deployed.
   */
  getInstances(): number;

  /**
   * Set the number of instances that should be deployed.
   */
  setInstances(instances: number): DeploymentOptions;

  /**
   * Sets the value of max worker execute time, in <a href="../../dataobjects.html#DeploymentOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#DeploymentOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a> is 
   */
  getMaxWorkerExecuteTime(): number;

  /**
   * Sets the value of max worker execute time, in <a href="../../dataobjects.html#DeploymentOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#DeploymentOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a> is 
   */
  setMaxWorkerExecuteTime(maxWorkerExecuteTime: number): DeploymentOptions;

  /**
   * Set the time unit of <code>maxWorkerExecuteTime</code>
   */
  getMaxWorkerExecuteTimeUnit(): any;

  /**
   * Set the time unit of <code>maxWorkerExecuteTime</code>
   */
  setMaxWorkerExecuteTimeUnit(maxWorkerExecuteTimeUnit: any): DeploymentOptions;

  /**
   * Set whether the verticle(s) should be deployed as a worker verticle
   */
  isWorker(): boolean;

  /**
   * Set whether the verticle(s) should be deployed as a worker verticle
   */
  setWorker(worker: boolean): DeploymentOptions;

  /**
   * Set the worker pool name to use for this verticle. When no name is set, the Vert.x
   * worker pool will be used, when a name is set, the verticle will use a named worker pool.
   */
  getWorkerPoolName(): string;

  /**
   * Set the worker pool name to use for this verticle. When no name is set, the Vert.x
   * worker pool will be used, when a name is set, the verticle will use a named worker pool.
   */
  setWorkerPoolName(workerPoolName: string): DeploymentOptions;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   */
  getWorkerPoolSize(): number;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   */
  setWorkerPoolSize(workerPoolSize: number): DeploymentOptions;

}

/**
 * Configuration options for Vert.x DNS client.
 */
export class DnsClientOptions {

  constructor();

  constructor(obj: DnsClientOptions);

  /**
   * Set the host name to be used by this client in requests.
   */
  getHost(): string;

  /**
   * Set the host name to be used by this client in requests.
   */
  setHost(host: string): DnsClientOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): DnsClientOptions;

  /**
   * Set the port to be used by this client in requests.
   */
  getPort(): number;

  /**
   * Set the port to be used by this client in requests.
   */
  setPort(port: number): DnsClientOptions;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   */
  getQueryTimeout(): number;

  /**
   * Set the query timeout in milliseconds, i.e the amount of time after a query is considered to be failed.
   */
  setQueryTimeout(queryTimeout: number): DnsClientOptions;

  /**
   * Set whether or not recursion is desired
   */
  isRecursionDesired(): boolean;

  /**
   * Set whether or not recursion is desired
   */
  setRecursionDesired(recursionDesired: boolean): DnsClientOptions;

}

import { ClientAuth } from './enums';

/**
 * Options to configure the event bus.
 */
export class EventBusOptions {

  constructor();

  constructor(obj: EventBusOptions);

  /**
   * Set the accept back log.
   */
  getAcceptBacklog(): number;

  /**
   * Set the accept back log.
   */
  setAcceptBacklog(acceptBacklog: number): EventBusOptions;

  /**
   * Set whether client auth is required
   */
  getClientAuth(): ClientAuth;

  /**
   * Set whether client auth is required
   */
  setClientAuth(clientAuth: ClientAuth): EventBusOptions;

  /**
   * Set information about this node when Vert.x is clustered.
   * <p>
   * The data may be used by the {@link NodeSelector} to select a node for a given message.
   * For example, it could be used to implement a partioning strategy.
   * <p>
   * The default {@link NodeSelector} does not use the node metadata.
   */
  getClusterNodeMetadata(): { [key: string]: any };

  /**
   * Set information about this node when Vert.x is clustered.
   * <p>
   * The data may be used by the {@link NodeSelector} to select a node for a given message.
   * For example, it could be used to implement a partioning strategy.
   * <p>
   * The default {@link NodeSelector} does not use the node metadata.
   */
  setClusterNodeMetadata(clusterNodeMetadata: { [key: string]: any }): EventBusOptions;

  /**
   * Set the value of cluster ping interval, in ms.
   */
  getClusterPingInterval(): number;

  /**
   * Set the value of cluster ping interval, in ms.
   */
  setClusterPingInterval(clusterPingInterval: number): EventBusOptions;

  /**
   * Set the value of cluster ping reply interval, in ms.
   */
  getClusterPingReplyInterval(): number;

  /**
   * Set the value of cluster ping reply interval, in ms.
   */
  setClusterPingReplyInterval(clusterPingReplyInterval: number): EventBusOptions;

  /**
   * Set the public facing hostname to be used for clustering.
   * Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is
   * not the same address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of
   * proxying. If this is the case you can specify a public hostname which is different from the hostname the
   * server listens at.
   * <p>
   * The default value is null which means use the same as the cluster hostname.
   */
  getClusterPublicHost(): string;

  /**
   * Set the public facing hostname to be used for clustering.
   * Sometimes, e.g. when running on certain clouds, the local address the server listens on for clustering is
   * not the same address that other nodes connect to it at, as the OS / cloud infrastructure does some kind of
   * proxying. If this is the case you can specify a public hostname which is different from the hostname the
   * server listens at.
   * <p>
   * The default value is null which means use the same as the cluster hostname.
   */
  setClusterPublicHost(clusterPublicHost: string): EventBusOptions;

  /**
   * See <a href="../../dataobjects.html#EventBusOptions">EventBusOptions</a> for an explanation.
   */
  getClusterPublicPort(): number;

  /**
   * See <a href="../../dataobjects.html#EventBusOptions">EventBusOptions</a> for an explanation.
   */
  setClusterPublicPort(clusterPublicPort: number): EventBusOptions;

  /**
   * Sets the connect timeout
   */
  getConnectTimeout(): number;

  /**
   * Sets the connect timeout
   */
  setConnectTimeout(connectTimeout: number): EventBusOptions;

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): EventBusOptions;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): EventBusOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): EventBusOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): EventBusOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): EventBusOptions;

  /**
   * Sets the host. Defaults to <code>null</code>.
   * <p>
   * When the clustered eventbus starts, it tries to bind to the provided <code>host</code>.
   * If <code>host</code> is <code>null</code>, then it tries to bind to the same host as the underlying cluster manager.
   * As a last resort, an address will be picked among the available network interfaces.
   */
  getHost(): string;

  /**
   * Sets the host. Defaults to <code>null</code>.
   * <p>
   * When the clustered eventbus starts, it tries to bind to the provided <code>host</code>.
   * If <code>host</code> is <code>null</code>, then it tries to bind to the same host as the underlying cluster manager.
   * As a last resort, an address will be picked among the available network interfaces.
   */
  setHost(host: string): EventBusOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#TCPSSLOptions">TCPSSLOptions</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#TCPSSLOptions">TCPSSLOptions</a>
   */
  setIdleTimeout(idleTimeout: number): EventBusOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): EventBusOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): EventBusOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): EventBusOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): EventBusOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): EventBusOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): EventBusOptions;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): EventBusOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): EventBusOptions;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): EventBusOptions;

  /**
   * Sets the port.
   */
  getPort(): number;

  /**
   * Sets the port.
   */
  setPort(port: number): EventBusOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): EventBusOptions;

  /**
   * Sets the value of reconnect attempts.
   */
  getReconnectAttempts(): number;

  /**
   * Sets the value of reconnect attempts.
   */
  setReconnectAttempts(reconnectAttempts: number): EventBusOptions;

  /**
   * Set the reconnect interval.
   */
  getReconnectInterval(): number;

  /**
   * Set the reconnect interval.
   */
  setReconnectInterval(reconnectInterval: number): EventBusOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): EventBusOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): EventBusOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): EventBusOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): EventBusOptions;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): EventBusOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): EventBusOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): EventBusOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): EventBusOptions;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): EventBusOptions;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): EventBusOptions;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): EventBusOptions;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): EventBusOptions;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): EventBusOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): EventBusOptions;

  /**
   * Set whether all server certificates should be trusted.
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted.
   */
  setTrustAll(trustAll: boolean): EventBusOptions;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): EventBusOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): EventBusOptions;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): EventBusOptions;

}

/**
 * Vert.x file system base configuration, this class can be extended by provider implementations to configure
 * those specific implementations.
 */
export class FileSystemOptions {

  constructor();

  constructor(obj: FileSystemOptions);

  /**
   * When vert.x cannot find the file on the filesystem it tries to resolve the
   * file from the class path when this is set to <code>true</code>.
   */
  isClassPathResolvingEnabled(): boolean;

  /**
   * When vert.x cannot find the file on the filesystem it tries to resolve the
   * file from the class path when this is set to <code>true</code>.
   */
  setClassPathResolvingEnabled(classPathResolvingEnabled: boolean): FileSystemOptions;

  /**
   * When vert.x reads a file that is packaged with the application it gets
   * extracted to this directory first and subsequent reads will use the extracted
   * file to get better IO performance.
   */
  getFileCacheDir(): string;

  /**
   * When vert.x reads a file that is packaged with the application it gets
   * extracted to this directory first and subsequent reads will use the extracted
   * file to get better IO performance.
   */
  setFileCacheDir(fileCacheDir: string): FileSystemOptions;

  /**
   * Set to <code>true</code> to cache files on the real file system
   * when the filesystem performs class path resolving.
   */
  isFileCachingEnabled(): boolean;

  /**
   * Set to <code>true</code> to cache files on the real file system
   * when the filesystem performs class path resolving.
   */
  setFileCachingEnabled(fileCachingEnabled: boolean): FileSystemOptions;

}


/**
 * A  frame.
 */
export class GoAway {

  constructor();

  constructor(obj: GoAway);

  /**
   * Set the additional debug data
   */
  getDebugData(): Buffer;

  /**
   * Set the additional debug data
   */
  setDebugData(debugData: Buffer): GoAway;

  /**
   */
  getErrorCode(): number;

  /**
   */
  setErrorCode(errorCode: number): GoAway;

  /**
   * Set the last stream id.
   */
  getLastStreamId(): number;

  /**
   * Set the last stream id.
   */
  setLastStreamId(lastStreamId: number): GoAway;

}

/**
 * HTTP2 settings, the settings is initialized with the default HTTP/2 values.<p>
 *
 * The settings expose the parameters defined by the HTTP/2 specification, as well as extra settings for
 * protocol extensions.
 */
export class Http2Settings {

  constructor();

  constructor(obj: Http2Settings);

  /**
   * Set  HTTP/2 setting.
   */
  getHeaderTableSize(): number;

  /**
   * Set  HTTP/2 setting.
   */
  setHeaderTableSize(headerTableSize: number): Http2Settings;

  /**
   * Set the  HTTP/2 setting
   */
  getInitialWindowSize(): number;

  /**
   * Set the  HTTP/2 setting
   */
  setInitialWindowSize(initialWindowSize: number): Http2Settings;

  /**
   * Set the  HTTP/2 setting
   */
  getMaxConcurrentStreams(): number;

  /**
   * Set the  HTTP/2 setting
   */
  setMaxConcurrentStreams(maxConcurrentStreams: number): Http2Settings;

  /**
   * Set the  HTTP/2 setting
   */
  getMaxFrameSize(): number;

  /**
   * Set the  HTTP/2 setting
   */
  setMaxFrameSize(maxFrameSize: number): Http2Settings;

  /**
   * Set the  HTTP/2 setting
   */
  getMaxHeaderListSize(): number;

  /**
   * Set the  HTTP/2 setting
   */
  setMaxHeaderListSize(maxHeaderListSize: number): Http2Settings;

  /**
   * Set the  HTTP/2 setting
   */
  isPushEnabled(): boolean;

  /**
   * Set the  HTTP/2 setting
   */
  setPushEnabled(pushEnabled: boolean): Http2Settings;

}

import { HttpVersion } from './enums';
import { TracingPolicy } from './enums';

/**
 * Options describing how an {@link HttpClient} will make connections.
 */
export class HttpClientOptions {

  constructor();

  constructor(obj: HttpClientOptions);

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiation.
   * When the list is empty, the client provides a best effort list according to <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>:
   *
   * <ul>
   *   <li>: [ "h2", "http/1.1" ]</li>
   *   <li>otherwise: [<a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>]</li>
   * </ul>
   */
  getAlpnVersions(): HttpVersion;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiation.
   * When the list is empty, the client provides a best effort list according to <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>:
   *
   * <ul>
   *   <li>: [ "h2", "http/1.1" ]</li>
   *   <li>otherwise: [<a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>]</li>
   * </ul>
   */
  setAlpnVersions(alpnVersions: HttpVersion): HttpClientOptions;

  /**
   * Set the connect timeout
   */
  getConnectTimeout(): number;

  /**
   * Set the connect timeout
   */
  setConnectTimeout(connectTimeout: number): HttpClientOptions;

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): HttpClientOptions;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): HttpClientOptions;

  /**
   * set to <code>initialBufferSizeHttpDecoder</code> the initial buffer of the HttpDecoder.
   */
  getDecoderInitialBufferSize(): number;

  /**
   * set to <code>initialBufferSizeHttpDecoder</code> the initial buffer of the HttpDecoder.
   */
  setDecoderInitialBufferSize(decoderInitialBufferSize: number): HttpClientOptions;

  /**
   * Set the default host name to be used by this client in requests if none is provided when making the request.
   */
  getDefaultHost(): string;

  /**
   * Set the default host name to be used by this client in requests if none is provided when making the request.
   */
  setDefaultHost(defaultHost: string): HttpClientOptions;

  /**
   * Set the default port to be used by this client in requests if none is provided when making the request.
   */
  getDefaultPort(): number;

  /**
   * Set the default port to be used by this client in requests if none is provided when making the request.
   */
  setDefaultPort(defaultPort: number): HttpClientOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): HttpClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): HttpClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): HttpClientOptions;

  /**
   * By default, the server name is only sent for Fully Qualified Domain Name (FQDN), setting
   * this property to <code>true</code> forces the server name to be always sent.
   */
  isForceSni(): boolean;

  /**
   * By default, the server name is only sent for Fully Qualified Domain Name (FQDN), setting
   * this property to <code>true</code> forces the server name to be always sent.
   */
  setForceSni(forceSni: boolean): HttpClientOptions;

  /**
   * Set to <code>true</code> when an <i>h2c</i> connection is established using an HTTP/1.1 upgrade request, and <code>false</code>
   * when an <i>h2c</i> connection is established directly (with prior knowledge).
   */
  isHttp2ClearTextUpgrade(): boolean;

  /**
   * Set to <code>true</code> when an <i>h2c</i> connection is established using an HTTP/1.1 upgrade request, and <code>false</code>
   * when an <i>h2c</i> connection is established directly (with prior knowledge).
   */
  setHttp2ClearTextUpgrade(http2ClearTextUpgrade: boolean): HttpClientOptions;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   * size set by <a href="../../dataobjects.html#Http2Settings">Http2Settings</a>, so the connection window size
   * is greater than for its streams, in order the data throughput.
   * <p/>
   * A value of <code>-1</code> reuses the initial window size setting.
   */
  getHttp2ConnectionWindowSize(): number;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   * size set by <a href="../../dataobjects.html#Http2Settings">Http2Settings</a>, so the connection window size
   * is greater than for its streams, in order the data throughput.
   * <p/>
   * A value of <code>-1</code> reuses the initial window size setting.
   */
  setHttp2ConnectionWindowSize(http2ConnectionWindowSize: number): HttpClientOptions;

  /**
   * Set the keep alive timeout for HTTP/2 connections, in seconds.
   * <p/>
   * This value determines how long a connection remains unused in the pool before being evicted and closed.
   * <p/>
   * A timeout of <code>0</code> means there is no timeout.
   */
  getHttp2KeepAliveTimeout(): number;

  /**
   * Set the keep alive timeout for HTTP/2 connections, in seconds.
   * <p/>
   * This value determines how long a connection remains unused in the pool before being evicted and closed.
   * <p/>
   * A timeout of <code>0</code> means there is no timeout.
   */
  setHttp2KeepAliveTimeout(http2KeepAliveTimeout: number): HttpClientOptions;

  /**
   * Set the maximum pool size for HTTP/2 connections
   */
  getHttp2MaxPoolSize(): number;

  /**
   * Set the maximum pool size for HTTP/2 connections
   */
  setHttp2MaxPoolSize(http2MaxPoolSize: number): HttpClientOptions;

  /**
   * Set a client limit of the number concurrent streams for each HTTP/2 connection, this limits the number
   * of streams the client can create for a connection. The effective number of streams for a
   * connection is the min of this value and the server's initial settings.
   * <p/>
   * Setting the value to <code>-1</code> means to use the value sent by the server's initial settings.
   * <code>-1</code> is the default value.
   */
  getHttp2MultiplexingLimit(): number;

  /**
   * Set a client limit of the number concurrent streams for each HTTP/2 connection, this limits the number
   * of streams the client can create for a connection. The effective number of streams for a
   * connection is the min of this value and the server's initial settings.
   * <p/>
   * Setting the value to <code>-1</code> means to use the value sent by the server's initial settings.
   * <code>-1</code> is the default value.
   */
  setHttp2MultiplexingLimit(http2MultiplexingLimit: number): HttpClientOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#HttpClientOptions">HttpClientOptions</a>
   */
  setIdleTimeout(idleTimeout: number): HttpClientOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): HttpClientOptions;

  /**
   * Set the HTTP/2 connection settings immediately sent by to the server when the client connects.
   */
  getInitialSettings(): Http2Settings;

  /**
   * Set the HTTP/2 connection settings immediately sent by to the server when the client connects.
   */
  setInitialSettings(initialSettings: Http2Settings): HttpClientOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): HttpClientOptions;

  /**
   * Set whether keep alive is enabled on the client
   */
  isKeepAlive(): boolean;

  /**
   * Set whether keep alive is enabled on the client
   */
  setKeepAlive(keepAlive: boolean): HttpClientOptions;

  /**
   * Set the keep alive timeout for HTTP/1.x, in seconds.
   * <p/>
   * This value determines how long a connection remains unused in the pool before being evicted and closed.
   * <p/>
   * A timeout of <code>0</code> means there is no timeout.
   */
  getKeepAliveTimeout(): number;

  /**
   * Set the keep alive timeout for HTTP/1.x, in seconds.
   * <p/>
   * This value determines how long a connection remains unused in the pool before being evicted and closed.
   * <p/>
   * A timeout of <code>0</code> means there is no timeout.
   */
  setKeepAliveTimeout(keepAliveTimeout: number): HttpClientOptions;

  /**
   * Set the key/cert options.
   */
  setKeyCertOptions(keyCertOptions: KeyCertOptions): HttpClientOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): HttpClientOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   * it will pick any local address, the default local address is null.
   */
  getLocalAddress(): string;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   * it will pick any local address, the default local address is null.
   */
  setLocalAddress(localAddress: string): HttpClientOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): HttpClientOptions;

  /**
   * Set the maximum HTTP chunk size
   */
  getMaxChunkSize(): number;

  /**
   * Set the maximum HTTP chunk size
   */
  setMaxChunkSize(maxChunkSize: number): HttpClientOptions;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   */
  getMaxHeaderSize(): number;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   */
  setMaxHeaderSize(maxHeaderSize: number): HttpClientOptions;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. <code>"HTTP/1.1 200 OK"</code>)
   */
  getMaxInitialLineLength(): number;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. <code>"HTTP/1.1 200 OK"</code>)
   */
  setMaxInitialLineLength(maxInitialLineLength: number): HttpClientOptions;

  /**
   * Set the maximum pool size for connections
   */
  getMaxPoolSize(): number;

  /**
   * Set the maximum pool size for connections
   */
  setMaxPoolSize(maxPoolSize: number): HttpClientOptions;

  /**
   * Set to <code>maxRedirects</code> the maximum number of redirection a request can follow.
   */
  getMaxRedirects(): number;

  /**
   * Set to <code>maxRedirects</code> the maximum number of redirection a request can follow.
   */
  setMaxRedirects(maxRedirects: number): HttpClientOptions;

  /**
   * Set the maximum requests allowed in the wait queue, any requests beyond the max size will result in
   * a ConnectionPoolTooBusyException.  If the value is set to a negative number then the queue will be unbounded.
   */
  getMaxWaitQueueSize(): number;

  /**
   * Set the maximum requests allowed in the wait queue, any requests beyond the max size will result in
   * a ConnectionPoolTooBusyException.  If the value is set to a negative number then the queue will be unbounded.
   */
  setMaxWaitQueueSize(maxWaitQueueSize: number): HttpClientOptions;

  /**
   * Set the max WebSocket frame size
   */
  getMaxWebSocketFrameSize(): number;

  /**
   * Set the max WebSocket frame size
   */
  setMaxWebSocketFrameSize(maxWebSocketFrameSize: number): HttpClientOptions;

  /**
   * Set the max WebSocket message size
   */
  getMaxWebSocketMessageSize(): number;

  /**
   * Set the max WebSocket message size
   */
  setMaxWebSocketMessageSize(maxWebSocketMessageSize: number): HttpClientOptions;

  /**
   * Set the max number of WebSockets per endpoint.
   */
  getMaxWebSockets(): number;

  /**
   * Set the max number of WebSockets per endpoint.
   */
  setMaxWebSockets(maxWebSockets: number): HttpClientOptions;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   * with the same name.
   */
  getMetricsName(): string;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   * with the same name.
   */
  setMetricsName(metricsName: string): HttpClientOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): HttpClientOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): HttpClientOptions;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): HttpClientOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): HttpClientOptions;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): HttpClientOptions;

  /**
   * Set whether pipe-lining is enabled on the client
   */
  isPipelining(): boolean;

  /**
   * Set whether pipe-lining is enabled on the client
   */
  setPipelining(pipelining: boolean): HttpClientOptions;

  /**
   * Set the limit of pending requests a pipe-lined HTTP/1 connection can send.
   */
  getPipeliningLimit(): number;

  /**
   * Set the limit of pending requests a pipe-lined HTTP/1 connection can send.
   */
  setPipeliningLimit(pipeliningLimit: number): HttpClientOptions;

  /**
   * Set the connection pool cleaner period in milli seconds, a non positive value disables expiration checks and connections
   * will remain in the pool until they are closed.
   */
  getPoolCleanerPeriod(): number;

  /**
   * Set the connection pool cleaner period in milli seconds, a non positive value disables expiration checks and connections
   * will remain in the pool until they are closed.
   */
  setPoolCleanerPeriod(poolCleanerPeriod: number): HttpClientOptions;

  /**
   * Set the protocol version.
   */
  getProtocolVersion(): HttpVersion;

  /**
   * Set the protocol version.
   */
  setProtocolVersion(protocolVersion: HttpVersion): HttpClientOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   */
  getProxyOptions(): ProxyOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   */
  setProxyOptions(proxyOptions: ProxyOptions): HttpClientOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): HttpClientOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): HttpClientOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): HttpClientOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): HttpClientOptions;

  /**
   * Set <code>true</code> when the client wants to skip frame masking.
   * <p>
   * You may want to set it <code>true</code> on server by server WebSocket communication: in this case you are by passing
   * RFC6455 protocol.
   * <p>
   * It's <code>false</code> as default.
   */
  isSendUnmaskedFrames(): boolean;

  /**
   * Set <code>true</code> when the client wants to skip frame masking.
   * <p>
   * You may want to set it <code>true</code> on server by server WebSocket communication: in this case you are by passing
   * RFC6455 protocol.
   * <p>
   * It's <code>false</code> as default.
   */
  setSendUnmaskedFrames(sendUnmaskedFrames: boolean): HttpClientOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): HttpClientOptions;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): HttpClientOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): HttpClientOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): HttpClientOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): HttpClientOptions;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): HttpClientOptions;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): HttpClientOptions;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): HttpClientOptions;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): HttpClientOptions;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): HttpClientOptions;

  /**
   * Set the tracing policy for the client behavior when Vert.x has tracing enabled.
   */
  getTracingPolicy(): TracingPolicy;

  /**
   * Set the tracing policy for the client behavior when Vert.x has tracing enabled.
   */
  setTracingPolicy(tracingPolicy: TracingPolicy): HttpClientOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): HttpClientOptions;

  /**
   * Set whether all server certificates should be trusted
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted
   */
  setTrustAll(trustAll: boolean): HttpClientOptions;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): HttpClientOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): HttpClientOptions;

  /**
   * Set whether compression is enabled
   */
  isTryUseCompression(): boolean;

  /**
   * Set whether compression is enabled
   */
  setTryUseCompression(tryUseCompression: boolean): HttpClientOptions;

  /**
   * Set whether the client will offer the WebSocket per-frame deflate compression extension.
   */
  setTryUsePerFrameWebSocketCompression(tryUsePerFrameWebSocketCompression: boolean): HttpClientOptions;

  /**
   * Set whether the client will offer the WebSocket per-message deflate compression extension.
   */
  getTryUsePerMessageWebSocketCompression(): boolean;

  /**
   * Set whether the client will offer the WebSocket per-message deflate compression extension.
   */
  setTryUsePerMessageWebSocketCompression(tryUsePerMessageWebSocketCompression: boolean): HttpClientOptions;

  /**
   */
  getTryWebSocketDeflateFrameCompression(): boolean;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): HttpClientOptions;

  /**
   * Set whether hostname verification is enabled
   */
  isVerifyHost(): boolean;

  /**
   * Set whether hostname verification is enabled
   */
  setVerifyHost(verifyHost: boolean): HttpClientOptions;

  /**
   * Set the amount of time a client WebSocket will wait until it closes the TCP connection after receiving a close frame.
   *
   * <p> When a WebSocket is closed, the server should close the TCP connection. This timeout will close
   * the TCP connection on the client when it expires.
   *
   * <p> Set <code>0L</code> or a negative value to disable.
   */
  getWebSocketClosingTimeout(): number;

  /**
   * Set the amount of time a client WebSocket will wait until it closes the TCP connection after receiving a close frame.
   *
   * <p> When a WebSocket is closed, the server should close the TCP connection. This timeout will close
   * the TCP connection on the client when it expires.
   *
   * <p> Set <code>0L</code> or a negative value to disable.
   */
  setWebSocketClosingTimeout(webSocketClosingTimeout: number): HttpClientOptions;

  /**
   * Set whether the <code>client_no_context_takeover</code> parameter of the WebSocket per-message
   * deflate compression extension will be offered.
   */
  getWebSocketCompressionAllowClientNoContext(): boolean;

  /**
   * Set whether the <code>client_no_context_takeover</code> parameter of the WebSocket per-message
   * deflate compression extension will be offered.
   */
  setWebSocketCompressionAllowClientNoContext(webSocketCompressionAllowClientNoContext: boolean): HttpClientOptions;

  /**
   * Set the WebSocket deflate compression level.
   */
  getWebSocketCompressionLevel(): number;

  /**
   * Set the WebSocket deflate compression level.
   */
  setWebSocketCompressionLevel(webSocketCompressionLevel: number): HttpClientOptions;

  /**
   * Set whether the <code>server_no_context_takeover</code> parameter of the WebSocket per-message
   * deflate compression extension will be offered.
   */
  getWebSocketCompressionRequestServerNoContext(): boolean;

  /**
   * Set whether the <code>server_no_context_takeover</code> parameter of the WebSocket per-message
   * deflate compression extension will be offered.
   */
  setWebSocketCompressionRequestServerNoContext(webSocketCompressionRequestServerNoContext: boolean): HttpClientOptions;

}

/**
 * Represents an HTTP method.
 */
export class HttpMethod {

  constructor(obj: HttpMethod);

}


/**
 * Represents options used by an {@link HttpServer} instance
 */
export class HttpServerOptions {

  constructor();

  constructor(obj: HttpServerOptions);

  /**
   * Set the accept back log
   */
  getAcceptBacklog(): number;

  /**
   * Set the accept back log
   */
  setAcceptBacklog(acceptBacklog: number): HttpServerOptions;

  /**
   * Set <code>true</code> when the server accepts unmasked frame.
   * As default Server doesn't accept unmasked frame, you can bypass this behaviour (RFC 6455) setting <code>true</code>.
   * It's set to <code>false</code> as default.
   */
  isAcceptUnmaskedFrames(): boolean;

  /**
   * Set <code>true</code> when the server accepts unmasked frame.
   * As default Server doesn't accept unmasked frame, you can bypass this behaviour (RFC 6455) setting <code>true</code>.
   * It's set to <code>false</code> as default.
   */
  setAcceptUnmaskedFrames(acceptUnmaskedFrames: boolean): HttpServerOptions;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiatiation.
   */
  getAlpnVersions(): HttpVersion;

  /**
   * Set the list of protocol versions to provide to the server during the Application-Layer Protocol Negotiatiation.
   */
  setAlpnVersions(alpnVersions: HttpVersion): HttpServerOptions;

  /**
   * Set whether client auth is required
   */
  getClientAuth(): ClientAuth;

  /**
   * Set whether client auth is required
   */
  setClientAuth(clientAuth: ClientAuth): HttpServerOptions;

  /**
   * This method allows to set the compression level to be used in http1.x/2 response bodies
   * when compression support is turned on (@see setCompressionSupported) and the client advertises
   * to support <code>deflate/gzip</code> compression in the <code>Accept-Encoding</code> header
   *
   * default value is : 6 (Netty legacy)
   *
   * The compression level determines how much the data is compressed on a scale from 1 to 9,
   * where '9' is trying to achieve the maximum compression ratio while '1' instead is giving
   * priority to speed instead of compression ratio using some algorithm optimizations and skipping
   * pedantic loops that usually gives just little improvements
   *
   * While one can think that best value is always the maximum compression ratio,
   * there's a trade-off to consider: the most compressed level requires the most
   * computational work to compress/decompress data, e.g. more dictionary lookups and loops.
   *
   * E.g. you have it set fairly high on a high-volume website, you may experience performance degradation
   * and latency on resource serving due to CPU overload, and, however - as the computational work is required also client side
   * while decompressing - setting an higher compression level can result in an overall higher page load time
   * especially nowadays when many clients are handled mobile devices with a low CPU profile.
   *
   * see also: http://www.gzip.org/algorithm.txt
   */
  getCompressionLevel(): number;

  /**
   * This method allows to set the compression level to be used in http1.x/2 response bodies
   * when compression support is turned on (@see setCompressionSupported) and the client advertises
   * to support <code>deflate/gzip</code> compression in the <code>Accept-Encoding</code> header
   *
   * default value is : 6 (Netty legacy)
   *
   * The compression level determines how much the data is compressed on a scale from 1 to 9,
   * where '9' is trying to achieve the maximum compression ratio while '1' instead is giving
   * priority to speed instead of compression ratio using some algorithm optimizations and skipping
   * pedantic loops that usually gives just little improvements
   *
   * While one can think that best value is always the maximum compression ratio,
   * there's a trade-off to consider: the most compressed level requires the most
   * computational work to compress/decompress data, e.g. more dictionary lookups and loops.
   *
   * E.g. you have it set fairly high on a high-volume website, you may experience performance degradation
   * and latency on resource serving due to CPU overload, and, however - as the computational work is required also client side
   * while decompressing - setting an higher compression level can result in an overall higher page load time
   * especially nowadays when many clients are handled mobile devices with a low CPU profile.
   *
   * see also: http://www.gzip.org/algorithm.txt
   */
  setCompressionLevel(compressionLevel: number): HttpServerOptions;

  /**
   * Set whether the server should support gzip/deflate compression
   * (serving compressed responses to clients advertising support for them with Accept-Encoding header)
   */
  isCompressionSupported(): boolean;

  /**
   * Set whether the server should support gzip/deflate compression
   * (serving compressed responses to clients advertising support for them with Accept-Encoding header)
   */
  setCompressionSupported(compressionSupported: boolean): HttpServerOptions;

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): HttpServerOptions;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): HttpServerOptions;

  /**
   * Set the initial buffer size for the HTTP decoder
   */
  getDecoderInitialBufferSize(): number;

  /**
   * Set the initial buffer size for the HTTP decoder
   */
  setDecoderInitialBufferSize(decoderInitialBufferSize: number): HttpServerOptions;

  /**
   * Set whether the server supports decompression
   */
  isDecompressionSupported(): boolean;

  /**
   * Set whether the server supports decompression
   */
  setDecompressionSupported(decompressionSupported: boolean): HttpServerOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): HttpServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): HttpServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): HttpServerOptions;

  /**
   * Set whether 100 Continue should be handled automatically
   */
  isHandle100ContinueAutomatically(): boolean;

  /**
   * Set whether 100 Continue should be handled automatically
   */
  setHandle100ContinueAutomatically(handle100ContinueAutomatically: boolean): HttpServerOptions;

  /**
   * Set the host
   */
  getHost(): string;

  /**
   * Set the host
   */
  setHost(host: string): HttpServerOptions;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   * size set by <a href="../../dataobjects.html#Http2Settings">Http2Settings</a>, so the connection window size
   * is greater than for its streams, in order the data throughput.
   * <p/>
   * A value of <code>-1</code> reuses the initial window size setting.
   */
  getHttp2ConnectionWindowSize(): number;

  /**
   * Set the default HTTP/2 connection window size. It overrides the initial window
   * size set by <a href="../../dataobjects.html#Http2Settings">Http2Settings</a>, so the connection window size
   * is greater than for its streams, in order the data throughput.
   * <p/>
   * A value of <code>-1</code> reuses the initial window size setting.
   */
  setHttp2ConnectionWindowSize(http2ConnectionWindowSize: number): HttpServerOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#HttpServerOptions">HttpServerOptions</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#HttpServerOptions">HttpServerOptions</a>
   */
  setIdleTimeout(idleTimeout: number): HttpServerOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): HttpServerOptions;

  /**
   * Set the HTTP/2 connection settings immediatly sent by the server when a client connects.
   */
  getInitialSettings(): Http2Settings;

  /**
   * Set the HTTP/2 connection settings immediatly sent by the server when a client connects.
   */
  setInitialSettings(initialSettings: Http2Settings): HttpServerOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): HttpServerOptions;

  /**
   * Set the key/cert options.
   */
  setKeyCertOptions(keyCertOptions: KeyCertOptions): HttpServerOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): HttpServerOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): HttpServerOptions;

  /**
   * Set the maximum HTTP chunk size that {@link HttpServerRequest#handler} will receive
   */
  getMaxChunkSize(): number;

  /**
   * Set the maximum HTTP chunk size that {@link HttpServerRequest#handler} will receive
   */
  setMaxChunkSize(maxChunkSize: number): HttpServerOptions;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   */
  getMaxHeaderSize(): number;

  /**
   * Set the maximum length of all headers for HTTP/1.x .
   */
  setMaxHeaderSize(maxHeaderSize: number): HttpServerOptions;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. <code>"GET / HTTP/1.0"</code>)
   */
  getMaxInitialLineLength(): number;

  /**
   * Set the maximum length of the initial line for HTTP/1.x (e.g. <code>"GET / HTTP/1.0"</code>)
   */
  setMaxInitialLineLength(maxInitialLineLength: number): HttpServerOptions;

  /**
   * Set the maximum WebSocket frames size
   */
  getMaxWebSocketFrameSize(): number;

  /**
   * Set the maximum WebSocket frames size
   */
  setMaxWebSocketFrameSize(maxWebSocketFrameSize: number): HttpServerOptions;

  /**
   * Set the maximum WebSocket message size
   */
  getMaxWebSocketMessageSize(): number;

  /**
   * Set the maximum WebSocket message size
   */
  setMaxWebSocketMessageSize(maxWebSocketMessageSize: number): HttpServerOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): HttpServerOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): HttpServerOptions;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): HttpServerOptions;

  /**
   * Enable or disable support for the WebSocket per-frame deflate compression extension.
   */
  getPerFrameWebSocketCompressionSupported(): boolean;

  /**
   * Enable or disable support for the WebSocket per-frame deflate compression extension.
   */
  setPerFrameWebSocketCompressionSupported(perFrameWebSocketCompressionSupported: boolean): HttpServerOptions;

  /**
   * Enable or disable support for WebSocket per-message deflate compression extension.
   */
  getPerMessageWebSocketCompressionSupported(): boolean;

  /**
   * Enable or disable support for WebSocket per-message deflate compression extension.
   */
  setPerMessageWebSocketCompressionSupported(perMessageWebSocketCompressionSupported: boolean): HttpServerOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): HttpServerOptions;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): HttpServerOptions;

  /**
   * Set the port
   */
  getPort(): number;

  /**
   * Set the port
   */
  setPort(port: number): HttpServerOptions;

  /**
   * Set the Proxy protocol timeout, default time unit is seconds.
   */
  getProxyProtocolTimeout(): number;

  /**
   * Set the Proxy protocol timeout, default time unit is seconds.
   */
  setProxyProtocolTimeout(proxyProtocolTimeout: number): HttpServerOptions;

  /**
   * Set the Proxy protocol timeout unit. If not specified, default is seconds.
   */
  getProxyProtocolTimeoutUnit(): any;

  /**
   * Set the Proxy protocol timeout unit. If not specified, default is seconds.
   */
  setProxyProtocolTimeoutUnit(proxyProtocolTimeoutUnit: any): HttpServerOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): HttpServerOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): HttpServerOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): HttpServerOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): HttpServerOptions;

  /**
   * Set whether the server supports Server Name Indiciation
   */
  isSni(): boolean;

  /**
   * Set whether the server supports Server Name Indiciation
   */
  setSni(sni: boolean): HttpServerOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): HttpServerOptions;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): HttpServerOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): HttpServerOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): HttpServerOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): HttpServerOptions;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): HttpServerOptions;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): HttpServerOptions;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): HttpServerOptions;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): HttpServerOptions;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): HttpServerOptions;

  /**
   * Set the tracing policy for the server behavior when Vert.x has tracing enabled.
   */
  getTracingPolicy(): TracingPolicy;

  /**
   * Set the tracing policy for the server behavior when Vert.x has tracing enabled.
   */
  setTracingPolicy(tracingPolicy: TracingPolicy): HttpServerOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): HttpServerOptions;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): HttpServerOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): HttpServerOptions;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): HttpServerOptions;

  /**
   * Set whether the server uses the HA Proxy protocol
   */
  isUseProxyProtocol(): boolean;

  /**
   * Set whether the server uses the HA Proxy protocol
   */
  setUseProxyProtocol(useProxyProtocol: boolean): HttpServerOptions;

  /**
   * Set whether the WebSocket server will accept the <code>server_no_context_takeover</code> parameter of the per-message
   * deflate compression extension offered by the client.
   */
  getWebSocketAllowServerNoContext(): boolean;

  /**
   * Set whether the WebSocket server will accept the <code>server_no_context_takeover</code> parameter of the per-message
   * deflate compression extension offered by the client.
   */
  setWebSocketAllowServerNoContext(webSocketAllowServerNoContext: boolean): HttpServerOptions;

  /**
   * Set the WebSocket compression level.
   */
  getWebSocketCompressionLevel(): number;

  /**
   * Set the WebSocket compression level.
   */
  setWebSocketCompressionLevel(webSocketCompressionLevel: number): HttpServerOptions;

  /**
   * Set whether the WebSocket server will accept the <code>client_no_context_takeover</code> parameter of the per-message
   * deflate compression extension offered by the client.
   */
  getWebSocketPreferredClientNoContext(): boolean;

  /**
   * Set whether the WebSocket server will accept the <code>client_no_context_takeover</code> parameter of the per-message
   * deflate compression extension offered by the client.
   */
  setWebSocketPreferredClientNoContext(webSocketPreferredClientNoContext: boolean): HttpServerOptions;

  /**
   * Set the WebSocket list of sub-protocol supported by the server.
   */
  getWebSocketSubProtocols(): string;

  /**
   * Set the WebSocket list of sub-protocol supported by the server.
   */
  setWebSocketSubProtocols(webSocketSubProtocols: string): HttpServerOptions;

  /**
   * Set the WebSocket list of sub-protocol supported by the server.
   */
  addWebSocketSubProtocol(webSocketSubProtocols: string): HttpServerOptions;

}

/**
 * Configures a <a href="../../dataobjects.html#TCPSSLOptions">TCPSSLOptions</a> to use the JDK ssl engine implementation.
 */
export class JdkSSLEngineOptions {

  constructor();

  constructor(obj: JdkSSLEngineOptions);

}


/**
 * Key or trust store options configuring private key and/or certificates based on Java Keystore files.
 */
export class JksOptions {

  constructor();

  constructor(obj: JksOptions);

  /**
   * Set the password for the key store
   */
  getPassword(): string;

  /**
   * Set the password for the key store
   */
  setPassword(password: string): JksOptions;

  /**
   * Set the path to the key store
   */
  getPath(): string;

  /**
   * Set the path to the key store
   */
  setPath(path: string): JksOptions;

  /**
   * Set the key store as a buffer
   */
  getValue(): Buffer;

  /**
   * Set the key store as a buffer
   */
  setValue(value: Buffer): JksOptions;

}


/**
 * Key or trust store options configuring private key and/or certificates based on <code>KeyStore</code>.
 *
 * <ul>
 *   <li>when used as a key store, it should point to a store containing a private key and its certificate.</li>
 *   <li>when used as a trust store, it should point to a store containing a list of trusted certificates.</li>
 * </ul>
 *
 * <p> The store can either be loaded by Vert.x from the filesystem:
 *
 * <pre>
 * HttpServerOptions options = HttpServerOptions.httpServerOptions();
 * options.setKeyCertOptions(new KeyStoreOptions().setType("JKS").setPath("/mykeystore.jks").setPassword("foo"));
 * </pre>
 *
 * Or directly provided as a buffer:
 *
 * <pre>
 * Buffer store = vertx.fileSystem().readFileBlocking("/mykeystore.jks");
 * options.setKeyCertOptions(new KeyStoreOptions().setType("JKS").setValue(store).setPassword("foo"));
 * </pre>
 *
 * <p> You can also use specific subclasses <a href="../../dataobjects.html#JksOptions">JksOptions</a> or <a href="../../dataobjects.html#PfxOptions">PfxOptions</a> that will set
 * the <a href="../../dataobjects.html#KeyStoreOptions">KeyStoreOptions</a> for you:
 *
 * <pre>
 * HttpServerOptions options = HttpServerOptions.httpServerOptions();
 * options.setKeyCertOptions(new JksOptions().setPath("/mykeystore.jks").setPassword("foo"));
 * </pre>
 */
export class KeyStoreOptions {

  constructor();

  constructor(obj: KeyStoreOptions);

  /**
   * Set the password for the key store
   */
  getPassword(): string;

  /**
   * Set the password for the key store
   */
  setPassword(password: string): KeyStoreOptions;

  /**
   * Set the path to the key store
   */
  getPath(): string;

  /**
   * Set the path to the key store
   */
  setPath(path: string): KeyStoreOptions;

  /**
   * Set the store provider.
   */
  getProvider(): string;

  /**
   * Set the store provider.
   */
  setProvider(provider: string): KeyStoreOptions;

  /**
   * Set the store type.
   */
  getType(): string;

  /**
   * Set the store type.
   */
  setType(type: string): KeyStoreOptions;

  /**
   * Set the key store as a buffer
   */
  getValue(): Buffer;

  /**
   * Set the key store as a buffer
   */
  setValue(value: Buffer): KeyStoreOptions;

}

/**
 * Vert.x metrics base configuration, this class can be extended by provider implementations to configure
 * those specific implementations.
 */
export class MetricsOptions {

  constructor();

  constructor(obj: MetricsOptions);

  /**
   * Set whether metrics will be enabled on the Vert.x instance.
   */
  isEnabled(): boolean;

  /**
   * Set whether metrics will be enabled on the Vert.x instance.
   */
  setEnabled(enabled: boolean): MetricsOptions;

  /**
   * Programmatically set the metrics factory to be used when metrics are enabled.
   * <p>
   * Only valid if <a href="../../dataobjects.html#MetricsOptions">MetricsOptions</a> = true.
   * <p>
   * Normally Vert.x will look on the classpath for a metrics factory implementation, but if you want to set one
   * programmatically you can use this method.
   */
  getFactory(): any /* io.vertx.core.spi.VertxMetricsFactory */;

  /**
   * Programmatically set the metrics factory to be used when metrics are enabled.
   * <p>
   * Only valid if <a href="../../dataobjects.html#MetricsOptions">MetricsOptions</a> = true.
   * <p>
   * Normally Vert.x will look on the classpath for a metrics factory implementation, but if you want to set one
   * programmatically you can use this method.
   */
  setFactory(factory: any /* io.vertx.core.spi.VertxMetricsFactory */): MetricsOptions;

}


/**
 * Options for configuring a {@link NetClient}.
 */
export class NetClientOptions {

  constructor();

  constructor(obj: NetClientOptions);

  /**
   * Set the connect timeout
   */
  getConnectTimeout(): number;

  /**
   * Set the connect timeout
   */
  setConnectTimeout(connectTimeout: number): NetClientOptions;

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): NetClientOptions;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): NetClientOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): NetClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): NetClientOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): NetClientOptions;

  /**
   * Set the hostname verification algorithm interval
   * To disable hostname verification, set hostnameVerificationAlgorithm to an empty String
   */
  getHostnameVerificationAlgorithm(): string;

  /**
   * Set the hostname verification algorithm interval
   * To disable hostname verification, set hostnameVerificationAlgorithm to an empty String
   */
  setHostnameVerificationAlgorithm(hostnameVerificationAlgorithm: string): NetClientOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#NetClientOptions">NetClientOptions</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#NetClientOptions">NetClientOptions</a>
   */
  setIdleTimeout(idleTimeout: number): NetClientOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): NetClientOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): NetClientOptions;

  /**
   * Set the key/cert options.
   */
  setKeyCertOptions(keyCertOptions: KeyCertOptions): NetClientOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): NetClientOptions;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   * it will pick any local address, the default local address is null.
   */
  getLocalAddress(): string;

  /**
   * Set the local interface to bind for network connections. When the local address is null,
   * it will pick any local address, the default local address is null.
   */
  setLocalAddress(localAddress: string): NetClientOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): NetClientOptions;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   * with the same name.
   */
  getMetricsName(): string;

  /**
   * Set the metrics name identifying the reported metrics, useful for grouping metrics
   * with the same name.
   */
  setMetricsName(metricsName: string): NetClientOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): NetClientOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): NetClientOptions;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): NetClientOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): NetClientOptions;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): NetClientOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   */
  getProxyOptions(): ProxyOptions;

  /**
   * Set proxy options for connections via CONNECT proxy (e.g. Squid) or a SOCKS proxy.
   */
  setProxyOptions(proxyOptions: ProxyOptions): NetClientOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): NetClientOptions;

  /**
   * Set the value of reconnect attempts
   */
  getReconnectAttempts(): number;

  /**
   * Set the value of reconnect attempts
   */
  setReconnectAttempts(reconnectAttempts: number): NetClientOptions;

  /**
   * Set the reconnect interval
   */
  getReconnectInterval(): number;

  /**
   * Set the reconnect interval
   */
  setReconnectInterval(reconnectInterval: number): NetClientOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): NetClientOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): NetClientOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): NetClientOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): NetClientOptions;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): NetClientOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): NetClientOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): NetClientOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): NetClientOptions;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): NetClientOptions;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): NetClientOptions;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): NetClientOptions;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): NetClientOptions;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): NetClientOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): NetClientOptions;

  /**
   * Set whether all server certificates should be trusted
   */
  isTrustAll(): boolean;

  /**
   * Set whether all server certificates should be trusted
   */
  setTrustAll(trustAll: boolean): NetClientOptions;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): NetClientOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): NetClientOptions;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): NetClientOptions;

}


/**
 * Options for configuring a {@link NetServer}.
 */
export class NetServerOptions {

  constructor();

  constructor(obj: NetServerOptions);

  /**
   * Set the accept back log
   */
  getAcceptBacklog(): number;

  /**
   * Set the accept back log
   */
  setAcceptBacklog(acceptBacklog: number): NetServerOptions;

  /**
   * Set whether client auth is required
   */
  getClientAuth(): ClientAuth;

  /**
   * Set whether client auth is required
   */
  setClientAuth(clientAuth: ClientAuth): NetServerOptions;

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): NetServerOptions;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): NetServerOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): NetServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): NetServerOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): NetServerOptions;

  /**
   * Set the host
   */
  getHost(): string;

  /**
   * Set the host
   */
  setHost(host: string): NetServerOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#NetServerOptions">NetServerOptions</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#NetServerOptions">NetServerOptions</a>
   */
  setIdleTimeout(idleTimeout: number): NetServerOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): NetServerOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): NetServerOptions;

  /**
   * Set the key/cert options.
   */
  setKeyCertOptions(keyCertOptions: KeyCertOptions): NetServerOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): NetServerOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): NetServerOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): NetServerOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): NetServerOptions;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): NetServerOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): NetServerOptions;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): NetServerOptions;

  /**
   * Set the port
   */
  getPort(): number;

  /**
   * Set the port
   */
  setPort(port: number): NetServerOptions;

  /**
   * Set the Proxy protocol timeout, default time unit is seconds.
   */
  getProxyProtocolTimeout(): number;

  /**
   * Set the Proxy protocol timeout, default time unit is seconds.
   */
  setProxyProtocolTimeout(proxyProtocolTimeout: number): NetServerOptions;

  /**
   * Set the Proxy protocol timeout unit. If not specified, default is seconds.
   */
  getProxyProtocolTimeoutUnit(): any;

  /**
   * Set the Proxy protocol timeout unit. If not specified, default is seconds.
   */
  setProxyProtocolTimeoutUnit(proxyProtocolTimeoutUnit: any): NetServerOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): NetServerOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): NetServerOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): NetServerOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): NetServerOptions;

  /**
   * Set whether the server supports Server Name Indiciation
   */
  isSni(): boolean;

  /**
   * Set whether the server supports Server Name Indiciation
   */
  setSni(sni: boolean): NetServerOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): NetServerOptions;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): NetServerOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): NetServerOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): NetServerOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): NetServerOptions;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): NetServerOptions;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): NetServerOptions;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): NetServerOptions;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): NetServerOptions;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): NetServerOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): NetServerOptions;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): NetServerOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): NetServerOptions;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): NetServerOptions;

  /**
   * Set whether the server uses the HA Proxy protocol
   */
  isUseProxyProtocol(): boolean;

  /**
   * Set whether the server uses the HA Proxy protocol
   */
  setUseProxyProtocol(useProxyProtocol: boolean): NetServerOptions;

}

/**
 */
export abstract class NetworkOptions {

  constructor();

  constructor(obj: NetworkOptions);

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): NetworkOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): NetworkOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): NetworkOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): NetworkOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): NetworkOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): NetworkOptions;

}

/**
 * Describes how an {@link AsyncFile} should be opened.
 */
export class OpenOptions {

  constructor();

  constructor(obj: OpenOptions);

  /**
   * Whether the file should be opened in append mode. Defaults to <code>false</code>.
   */
  isAppend(): boolean;

  /**
   * Whether the file should be opened in append mode. Defaults to <code>false</code>.
   */
  setAppend(append: boolean): OpenOptions;

  /**
   * Set whether the file should be created if it does not already exist.
   */
  isCreate(): boolean;

  /**
   * Set whether the file should be created if it does not already exist.
   */
  setCreate(create: boolean): OpenOptions;

  /**
   * Set whether the file should be created and fail if it does exist already.
   */
  isCreateNew(): boolean;

  /**
   * Set whether the file should be created and fail if it does exist already.
   */
  setCreateNew(createNew: boolean): OpenOptions;

  /**
   * Set whether the file should be deleted when it's closed, or the JVM is shutdown.
   */
  isDeleteOnClose(): boolean;

  /**
   * Set whether the file should be deleted when it's closed, or the JVM is shutdown.
   */
  setDeleteOnClose(deleteOnClose: boolean): OpenOptions;

  /**
   * Set whether every write to the file's content  ill be written synchronously to the underlying hardware.
   */
  isDsync(): boolean;

  /**
   * Set whether every write to the file's content  ill be written synchronously to the underlying hardware.
   */
  setDsync(dsync: boolean): OpenOptions;

  /**
   * Set the permissions string
   */
  getPerms(): string;

  /**
   * Set the permissions string
   */
  setPerms(perms: string): OpenOptions;

  /**
   * Set whether the file is to be opened for reading
   */
  isRead(): boolean;

  /**
   * Set whether the file is to be opened for reading
   */
  setRead(read: boolean): OpenOptions;

  /**
   * Set whether a hint should be provided that the file to created is sparse
   */
  isSparse(): boolean;

  /**
   * Set whether a hint should be provided that the file to created is sparse
   */
  setSparse(sparse: boolean): OpenOptions;

  /**
   * Set whether every write to the file's content and meta-data will be written synchronously to the underlying hardware.
   */
  isSync(): boolean;

  /**
   * Set whether every write to the file's content and meta-data will be written synchronously to the underlying hardware.
   */
  setSync(sync: boolean): OpenOptions;

  /**
   * Set whether the file should be truncated to zero length on opening if it exists and is opened for write
   */
  isTruncateExisting(): boolean;

  /**
   * Set whether the file should be truncated to zero length on opening if it exists and is opened for write
   */
  setTruncateExisting(truncateExisting: boolean): OpenOptions;

  /**
   * Set whether the file is to be opened for writing
   */
  isWrite(): boolean;

  /**
   * Set whether the file is to be opened for writing
   */
  setWrite(write: boolean): OpenOptions;

}

/**
 * Configures a <a href="../../dataobjects.html#TCPSSLOptions">TCPSSLOptions</a> to use OpenSsl.
 */
export class OpenSSLEngineOptions {

  constructor();

  constructor(obj: OpenSSLEngineOptions);

  /**
   * Set whether session cache is enabled in open SSL session server context
   */
  isSessionCacheEnabled(): boolean;

  /**
   * Set whether session cache is enabled in open SSL session server context
   */
  setSessionCacheEnabled(sessionCacheEnabled: boolean): OpenSSLEngineOptions;

}

/**
 * Models command line options. Options are values passed to a command line interface using -x or --x. Supported
 * syntaxes depend on the parser.
 * <p/>
 * Short name is generally used with a single dash, while long name requires a double-dash.
 */
export class Option {

  constructor();

  constructor(obj: Option);

  /**
   * Sets te arg name for this option.
   */
  getArgName(): string;

  /**
   * Sets te arg name for this option.
   */
  setArgName(argName: string): Option;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   * values, a {@link InvalidValueException} exception is thrown.
   */
  getChoices(): string;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   * values, a {@link InvalidValueException} exception is thrown.
   */
  setChoices(choices: string): Option;

  /**
   * Sets the list of values accepted by this option. If the value set by the user does not match once of these
   * values, a {@link InvalidValueException} exception is thrown.
   */
  addChoice(choices: string): Option;

  /**
   * Sets the default value of this option
   */
  getDefaultValue(): string;

  /**
   * Sets the default value of this option
   */
  setDefaultValue(defaultValue: string): Option;

  /**
   * Sets te description of this option.
   */
  getDescription(): string;

  /**
   * Sets te description of this option.
   */
  setDescription(description: string): Option;

  /**
   * Configures the current <a href="../../dataobjects.html#Option">Option</a> to be a flag. It will be evaluated to <code>true</code> if it's found in
   * the command line. If you need a flag that may receive a value, use, in this order:
   * <code><pre>
   *   option.setFlag(true).setSingleValued(true)
   * </pre></code>
   */
  isFlag(): boolean;

  /**
   * Configures the current <a href="../../dataobjects.html#Option">Option</a> to be a flag. It will be evaluated to <code>true</code> if it's found in
   * the command line. If you need a flag that may receive a value, use, in this order:
   * <code><pre>
   *   option.setFlag(true).setSingleValued(true)
   * </pre></code>
   */
  setFlag(flag: boolean): Option;

  /**
   * Sets whether or not this option is a "help" option
   */
  isHelp(): boolean;

  /**
   * Sets whether or not this option is a "help" option
   */
  setHelp(help: boolean): Option;

  /**
   * Sets whether or not this option should be hidden
   */
  isHidden(): boolean;

  /**
   * Sets whether or not this option should be hidden
   */
  setHidden(hidden: boolean): Option;

  /**
   * Sets the long name of this option.
   */
  getLongName(): string;

  /**
   * Sets the long name of this option.
   */
  setLongName(longName: string): Option;

  /**
   * Sets whether or not this option can receive several values.
   */
  isMultiValued(): boolean;

  /**
   * Sets whether or not this option can receive several values.
   */
  setMultiValued(multiValued: boolean): Option;

  /**
   */
  getName(): string;

  /**
   * Sets whether or not this option is mandatory.
   */
  isRequired(): boolean;

  /**
   * Sets whether or not this option is mandatory.
   */
  setRequired(required: boolean): Option;

  /**
   * Sets the short name of this option.
   */
  getShortName(): string;

  /**
   * Sets the short name of this option.
   */
  setShortName(shortName: string): Option;

  /**
   * Sets whether or not this option can receive a value.
   */
  isSingleValued(): boolean;

  /**
   * Sets whether or not this option can receive a value.
   */
  setSingleValued(singleValued: boolean): Option;

}


/**
 * Key store options configuring a list of private key and its certificate based on
 * <i>Privacy-enhanced Electronic Email</i> (PEM) files.
 * <p>
 *
 * A key file must contain a <b>non encrypted</b> private key in <b>PKCS8</b> format wrapped in a PEM
 * block, for example:
 * <p>
 *
 * <pre>
 * -----BEGIN PRIVATE KEY-----
 * MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDV6zPk5WqLwS0a
 * ...
 * K5xBhtm1AhdnZjx5KfW3BecE
 * -----END PRIVATE KEY-----
 * </pre><p>
 *
 * Or contain a <b>non encrypted</b> private key in <b>PKCS1</b> format wrapped in a PEM
 * block, for example:
 * <p>
 *
 * <pre>
 * -----BEGIN RSA PRIVATE KEY-----
 * MIIEowIBAAKCAQEAlO4gbHeFb/fmbUF/tOJfNPJumJUEqgzAzx8MBXv9Acyw9IRa
 * ...
 * zJ14Yd+t2fsLYVs2H0gxaA4DW6neCzgY3eKpSU0EBHUCFSXp/1+/
 * -----END RSA PRIVATE KEY-----
 * </pre><p>
 *
 * A certificate file must contain an X.509 certificate wrapped in a PEM block, for example:
 * <p>
 *
 * <pre>
 * -----BEGIN CERTIFICATE-----
 * MIIDezCCAmOgAwIBAgIEZOI/3TANBgkqhkiG9w0BAQsFADBuMRAwDgYDVQQGEwdV
 * ...
 * +tmLSvYS39O2nqIzzAUfztkYnUlZmB0l/mKkVqbGJA==
 * -----END CERTIFICATE-----
 * </pre>
 *
 * Keys and certificates can either be loaded by Vert.x from the filesystem:
 * <p>
 * <pre>
 * HttpServerOptions options = new HttpServerOptions();
 * options.setPemKeyCertOptions(new PemKeyCertOptions().setKeyPath("/mykey.pem").setCertPath("/mycert.pem"));
 * </pre>
 *
 * Or directly provided as a buffer:<p>
 *
 * <pre>
 * Buffer key = vertx.fileSystem().readFileBlocking("/mykey.pem");
 * Buffer cert = vertx.fileSystem().readFileBlocking("/mycert.pem");
 * options.setPemKeyCertOptions(new PemKeyCertOptions().setKeyValue(key).setCertValue(cert));
 * </pre>
 *
 * Several key/certificate pairs can be used:
 * <p>
 * <pre>
 * HttpServerOptions options = new HttpServerOptions();
 * options.setPemKeyCertOptions(new PemKeyCertOptions()
 *    .addKeyPath("/mykey1.pem").addCertPath("/mycert1.pem")
 *    .addKeyPath("/mykey2.pem").addCertPath("/mycert2.pem"));
 * </pre>
 */
export class PemKeyCertOptions {

  constructor();

  constructor(obj: PemKeyCertOptions);

  /**
   * Set the path of the first certificate, replacing the previous certificates paths
   */
  setCertPath(certPath: string): PemKeyCertOptions;

  /**
   * Set all the paths to the certificates files
   */
  getCertPaths(): string;

  /**
   * Set all the paths to the certificates files
   */
  setCertPaths(certPaths: string): PemKeyCertOptions;

  /**
   * Set the first certificate as a buffer, replacing the previous certificates buffers
   */
  setCertValue(certValue: Buffer): PemKeyCertOptions;

  /**
   * Set all the certificates as a list of buffer
   */
  getCertValues(): Buffer;

  /**
   * Set all the certificates as a list of buffer
   */
  setCertValues(certValues: Buffer): PemKeyCertOptions;

  /**
   * Set the path of the first key file, replacing the keys paths
   */
  setKeyPath(keyPath: string): PemKeyCertOptions;

  /**
   * Set all the paths to the keys files
   */
  getKeyPaths(): string;

  /**
   * Set all the paths to the keys files
   */
  setKeyPaths(keyPaths: string): PemKeyCertOptions;

  /**
   * Set the first key a a buffer, replacing the previous keys buffers
   */
  setKeyValue(keyValue: Buffer): PemKeyCertOptions;

  /**
   * Set all the keys as a list of buffer
   */
  getKeyValues(): Buffer;

  /**
   * Set all the keys as a list of buffer
   */
  setKeyValues(keyValues: Buffer): PemKeyCertOptions;

}


/**
 * Certificate Authority options configuring certificates based on
 * <i>Privacy-enhanced Electronic Email</i> (PEM) files. The options is configured with a list of
 * validating certificates.
 * <p>
 * Validating certificates must contain X.509 certificates wrapped in a PEM block:<p>
 *
 * <pre>
 * -----BEGIN CERTIFICATE-----
 * MIIDezCCAmOgAwIBAgIEVmLkwTANBgkqhkiG9w0BAQsFADBuMRAwDgYDVQQGEwdV
 * ...
 * z5+DuODBJUQst141Jmgq8bS543IU/5apcKQeGNxEyQ==
 * -----END CERTIFICATE-----
 * </pre>
 *
 * The certificates can either be loaded by Vert.x from the filesystem:
 * <p>
 * <pre>
 * HttpServerOptions options = new HttpServerOptions();
 * options.setPemTrustOptions(new PemTrustOptions().addCertPath("/cert.pem"));
 * </pre>
 *
 * Or directly provided as a buffer:
 * <p>
 *
 * <pre>
 * Buffer cert = vertx.fileSystem().readFileBlocking("/cert.pem");
 * HttpServerOptions options = new HttpServerOptions();
 * options.setPemTrustOptions(new PemTrustOptions().addCertValue(cert));
 * </pre>
 */
export class PemTrustOptions {

  constructor();

  constructor(obj: PemTrustOptions);

  /**
   * Add a certificate path
   */
  getCertPaths(): string;

  /**
   * Add a certificate path
   */
  addCertPath(certPaths: string): PemTrustOptions;

  /**
   * Add a certificate value
   */
  getCertValues(): Buffer;

  /**
   * Add a certificate value
   */
  addCertValue(certValues: Buffer): PemTrustOptions;

}


/**
 * Key or trust store options configuring private key and/or certificates based on PKCS#12 files.
 */
export class PfxOptions {

  constructor();

  constructor(obj: PfxOptions);

  /**
   * Set the password for the key store
   */
  getPassword(): string;

  /**
   * Set the password for the key store
   */
  setPassword(password: string): PfxOptions;

  /**
   * Set the path to the key store
   */
  getPath(): string;

  /**
   * Set the path to the key store
   */
  setPath(path: string): PfxOptions;

  /**
   * Set the key store as a buffer
   */
  getValue(): Buffer;

  /**
   * Set the key store as a buffer
   */
  setValue(value: Buffer): PfxOptions;

}

import { ProxyType } from './enums';

/**
 * Proxy options for a net client or a net client.
 */
export class ProxyOptions {

  constructor();

  constructor(obj: ProxyOptions);

  /**
   * Set proxy host.
   */
  getHost(): string;

  /**
   * Set proxy host.
   */
  setHost(host: string): ProxyOptions;

  /**
   * Set proxy password.
   */
  getPassword(): string;

  /**
   * Set proxy password.
   */
  setPassword(password: string): ProxyOptions;

  /**
   * Set proxy port.
   */
  getPort(): number;

  /**
   * Set proxy port.
   */
  setPort(port: number): ProxyOptions;

  /**
   * Set proxy type.
   *
   * <p>ProxyType can be HTTP, SOCKS4 and SOCKS5
   */
  getType(): ProxyType;

  /**
   * Set proxy type.
   *
   * <p>ProxyType can be HTTP, SOCKS4 and SOCKS5
   */
  setType(type: ProxyType): ProxyOptions;

  /**
   * Set proxy username.
   */
  getUsername(): string;

  /**
   * Set proxy username.
   */
  setUsername(username: string): ProxyOptions;

}

import { SocketAddress } from './index';

/**
 * Options describing how an {@link HttpClient} will connect to make a request.
 */
export class RequestOptions {

  constructor();

  constructor(obj: RequestOptions);

  /**
   * Parse an absolute URI to use, this will update the <code>ssl</code>, <code>host</code>,
   * <code>port</code> and <code>uri</code> fields.
   */
  setAbsoluteURI(absoluteURI: string): RequestOptions;

  /**
   * Set whether to follow HTTP redirect
   */
  getFollowRedirects(): boolean;

  /**
   * Set whether to follow HTTP redirect
   */
  setFollowRedirects(followRedirects: boolean): RequestOptions;

  /**
   * Add a request header.
   */
  addHeader(key: string, headers: string): RequestOptions;

  /**
   * Set the host name to be used by the client request.
   */
  getHost(): string;

  /**
   * Set the host name to be used by the client request.
   */
  setHost(host: string): RequestOptions;

  /**
   * Set the HTTP method to be used by the client request.
   */
  getMethod(): HttpMethod;

  /**
   * Set the HTTP method to be used by the client request.
   */
  setMethod(method: HttpMethod): RequestOptions;

  /**
   * Set the port to be used by the client request.
   */
  getPort(): number;

  /**
   * Set the port to be used by the client request.
   */
  setPort(port: number): RequestOptions;

  /**
   * Set the server address to be used by the client request.
   *
   * <p> When the server address is <code>null</code>, the address will be resolved after the <code>host</code>
   * property by the Vert.x resolver.
   *
   * <p> Use this when you want to connect to a specific server address without name resolution.
   */
  getServer(): SocketAddress;

  /**
   * Set the server address to be used by the client request.
   *
   * <p> When the server address is <code>null</code>, the address will be resolved after the <code>host</code>
   * property by the Vert.x resolver.
   *
   * <p> Use this when you want to connect to a specific server address without name resolution.
   */
  setServer(server: SocketAddress): RequestOptions;

  /**
   * Set whether SSL/TLS is enabled.
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled.
   */
  setSsl(ssl: boolean): RequestOptions;

  /**
   * Sets the amount of time after which if the request does not return any data within the timeout period an
   * TimeoutException will be passed to the exception handler and
   * the request will be closed.
   */
  getTimeout(): number;

  /**
   * Sets the amount of time after which if the request does not return any data within the timeout period an
   * TimeoutException will be passed to the exception handler and
   * the request will be closed.
   */
  setTimeout(timeout: number): RequestOptions;

  /**
   * Set the request relative URI.
   */
  getURI(): string;

  /**
   * Set the request relative URI.
   */
  setURI(uri: string): RequestOptions;

}

/**
 * This class represents HTTP/2 stream priority defined in RFC 7540 clause 5.3
 */
export class StreamPriority {

  constructor();

  constructor(obj: StreamPriority);

  /**
   * Set the priority dependency value.
   */
  getDependency(): number;

  /**
   * Set the priority dependency value.
   */
  setDependency(dependency: number): StreamPriority;

  /**
   * Set the priority exclusive value.
   */
  isExclusive(): boolean;

  /**
   * Set the priority exclusive value.
   */
  setExclusive(exclusive: boolean): StreamPriority;

  /**
   * Set the priority weight.
   */
  getWeight(): number;

  /**
   * Set the priority weight.
   */
  setWeight(weight: number): StreamPriority;

}


/**
 * Base class. TCP and SSL related options
 */
export abstract class TCPSSLOptions {

  constructor();

  constructor(obj: TCPSSLOptions);

  /**
   * Add a CRL path
   */
  getCrlPaths(): string;

  /**
   * Add a CRL path
   */
  addCrlPath(crlPaths: string): TCPSSLOptions;

  /**
   * Add a CRL value
   */
  getCrlValues(): Buffer;

  /**
   * Add a CRL value
   */
  addCrlValue(crlValues: Buffer): TCPSSLOptions;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  getEnabledCipherSuites(): string;

  /**
   * Add an enabled cipher suite, appended to the ordered suites.
   */
  addEnabledCipherSuite(enabledCipherSuites: string): TCPSSLOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  getEnabledSecureTransportProtocols(): string;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  setEnabledSecureTransportProtocols(enabledSecureTransportProtocols: string): TCPSSLOptions;

  /**
   * Sets the list of enabled SSL/TLS protocols.
   */
  addEnabledSecureTransportProtocol(enabledSecureTransportProtocols: string): TCPSSLOptions;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#TCPSSLOptions">TCPSSLOptions</a>
   */
  getIdleTimeout(): number;

  /**
   * Set the idle timeout, default time unit is seconds. Zero means don't timeout.
   * This determines if a connection will timeout and be closed if no data is received within the timeout.
   *
   * If you want change default time unit, use <a href="../../dataobjects.html#TCPSSLOptions">TCPSSLOptions</a>
   */
  setIdleTimeout(idleTimeout: number): TCPSSLOptions;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  getIdleTimeoutUnit(): any;

  /**
   * Set the idle timeout unit. If not specified, default is seconds.
   */
  setIdleTimeoutUnit(idleTimeoutUnit: any): TCPSSLOptions;

  getJdkSslEngineOptions(): JdkSSLEngineOptions;

  setJdkSslEngineOptions(jdkSslEngineOptions: JdkSSLEngineOptions): TCPSSLOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  getKeyStoreOptions(): JksOptions;

  /**
   * Set the key/cert options in jks format, aka Java keystore.
   */
  setKeyStoreOptions(keyStoreOptions: JksOptions): TCPSSLOptions;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  getLogActivity(): boolean;

  /**
   * Set to true to enabled network activity logging: Netty's pipeline is configured for logging on Netty's logger.
   */
  setLogActivity(logActivity: boolean): TCPSSLOptions;

  getOpenSslEngineOptions(): OpenSSLEngineOptions;

  setOpenSslEngineOptions(openSslEngineOptions: OpenSSLEngineOptions): TCPSSLOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  getPemKeyCertOptions(): PemKeyCertOptions;

  /**
   * Set the key/cert store options in pem format.
   */
  setPemKeyCertOptions(pemKeyCertOptions: PemKeyCertOptions): TCPSSLOptions;

  /**
   * Set the trust options in pem format
   */
  getPemTrustOptions(): PemTrustOptions;

  /**
   * Set the trust options in pem format
   */
  setPemTrustOptions(pemTrustOptions: PemTrustOptions): TCPSSLOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  getPfxKeyCertOptions(): PfxOptions;

  /**
   * Set the key/cert options in pfx format.
   */
  setPfxKeyCertOptions(pfxKeyCertOptions: PfxOptions): TCPSSLOptions;

  /**
   * Set the trust options in pfx format
   */
  getPfxTrustOptions(): PfxOptions;

  /**
   * Set the trust options in pfx format
   */
  setPfxTrustOptions(pfxTrustOptions: PfxOptions): TCPSSLOptions;

  /**
   * Set the TCP receive buffer size
   */
  getReceiveBufferSize(): number;

  /**
   * Set the TCP receive buffer size
   */
  setReceiveBufferSize(receiveBufferSize: number): TCPSSLOptions;

  /**
   * Set the value of reuse address
   */
  isReuseAddress(): boolean;

  /**
   * Set the value of reuse address
   */
  setReuseAddress(reuseAddress: boolean): TCPSSLOptions;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  isReusePort(): boolean;

  /**
   * Set the value of reuse port.
   * <p/>
   * This is only supported by native transports.
   */
  setReusePort(reusePort: boolean): TCPSSLOptions;

  /**
   * Set the TCP send buffer size
   */
  getSendBufferSize(): number;

  /**
   * Set the TCP send buffer size
   */
  setSendBufferSize(sendBufferSize: number): TCPSSLOptions;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  getSoLinger(): number;

  /**
   * Set whether SO_linger keep alive is enabled
   */
  setSoLinger(soLinger: number): TCPSSLOptions;

  /**
   * Set whether SSL/TLS is enabled
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled
   */
  setSsl(ssl: boolean): TCPSSLOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  getSslEngineOptions(): SSLEngineOptions;

  /**
   * Set to use SSL engine implementation to use.
   */
  setSslEngineOptions(sslEngineOptions: SSLEngineOptions): TCPSSLOptions;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  getSslHandshakeTimeout(): number;

  /**
   * Set the SSL handshake timeout, default time unit is seconds.
   */
  setSslHandshakeTimeout(sslHandshakeTimeout: number): TCPSSLOptions;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  getSslHandshakeTimeoutUnit(): any;

  /**
   * Set the SSL handshake timeout unit. If not specified, default is seconds.
   */
  setSslHandshakeTimeoutUnit(sslHandshakeTimeoutUnit: any): TCPSSLOptions;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  isTcpCork(): boolean;

  /**
   * Enable the <code>TCP_CORK</code> option - only with linux native transport.
   */
  setTcpCork(tcpCork: boolean): TCPSSLOptions;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  isTcpFastOpen(): boolean;

  /**
   * Enable the <code>TCP_FASTOPEN</code> option - only with linux native transport.
   */
  setTcpFastOpen(tcpFastOpen: boolean): TCPSSLOptions;

  /**
   * Set whether TCP keep alive is enabled
   */
  isTcpKeepAlive(): boolean;

  /**
   * Set whether TCP keep alive is enabled
   */
  setTcpKeepAlive(tcpKeepAlive: boolean): TCPSSLOptions;

  /**
   * Set whether TCP no delay is enabled
   */
  isTcpNoDelay(): boolean;

  /**
   * Set whether TCP no delay is enabled
   */
  setTcpNoDelay(tcpNoDelay: boolean): TCPSSLOptions;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  isTcpQuickAck(): boolean;

  /**
   * Enable the <code>TCP_QUICKACK</code> option - only with linux native transport.
   */
  setTcpQuickAck(tcpQuickAck: boolean): TCPSSLOptions;

  /**
   * Set the value of traffic class
   */
  getTrafficClass(): number;

  /**
   * Set the value of traffic class
   */
  setTrafficClass(trafficClass: number): TCPSSLOptions;

  /**
   * Set the trust options.
   */
  getTrustOptions(): TrustOptions;

  /**
   * Set the trust options.
   */
  setTrustOptions(trustOptions: TrustOptions): TCPSSLOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  getTrustStoreOptions(): JksOptions;

  /**
   * Set the trust options in jks format, aka Java truststore
   */
  setTrustStoreOptions(trustStoreOptions: JksOptions): TCPSSLOptions;

  /**
   * Set the ALPN usage.
   */
  isUseAlpn(): boolean;

  /**
   * Set the ALPN usage.
   */
  setUseAlpn(useAlpn: boolean): TCPSSLOptions;

}

/**
 * Vert.x tracing base configuration, this class can be extended by provider implementations to configure
 * those specific implementations.
 */
export class TracingOptions {

  constructor();

  constructor(obj: TracingOptions);

  /**
   * Programmatically set the tracer factory to be used when tracing are enabled.
   * <p>
   * Normally Vert.x will look on the classpath for a tracer factory implementation, but if you want to set one
   * programmatically you can use this method.
   */
  getFactory(): any /* io.vertx.core.spi.VertxTracerFactory */;

  /**
   * Programmatically set the tracer factory to be used when tracing are enabled.
   * <p>
   * Normally Vert.x will look on the classpath for a tracer factory implementation, but if you want to set one
   * programmatically you can use this method.
   */
  setFactory(factory: any /* io.vertx.core.spi.VertxTracerFactory */): TracingOptions;

}

/**
 * Instances of this class are used to configure {@link Vertx} instances.
 */
export class VertxOptions {

  constructor();

  constructor(obj: VertxOptions);

  /**
   * Sets the address resolver configuration to configure resolving DNS servers, cache TTL, etc...
   */
  getAddressResolverOptions(): AddressResolverOptions;

  /**
   * Sets the address resolver configuration to configure resolving DNS servers, cache TTL, etc...
   */
  setAddressResolverOptions(addressResolverOptions: AddressResolverOptions): VertxOptions;

  /**
   * Sets the value of blocked thread check period, in <a href="../../dataobjects.html#VertxOptions">#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit</a> is 
   */
  getBlockedThreadCheckInterval(): number;

  /**
   * Sets the value of blocked thread check period, in <a href="../../dataobjects.html#VertxOptions">#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setBlockedThreadCheckIntervalUnit blockedThreadCheckIntervalUnit</a> is 
   */
  setBlockedThreadCheckInterval(blockedThreadCheckInterval: number): VertxOptions;

  /**
   * Set the time unit of <code>blockedThreadCheckInterval</code>.
   */
  getBlockedThreadCheckIntervalUnit(): any;

  /**
   * Set the time unit of <code>blockedThreadCheckInterval</code>.
   */
  setBlockedThreadCheckIntervalUnit(blockedThreadCheckIntervalUnit: any): VertxOptions;

  /**
   * Programmatically set the cluster manager to be used when clustering.
   * <p>
   * Only valid if clustered = true.
   * <p>
   * Normally Vert.x will look on the classpath for a cluster manager, but if you want to set one
   * programmatically you can use this method.
   */
  getClusterManager(): any /* io.vertx.core.spi.cluster.ClusterManager */;

  /**
   * Programmatically set the cluster manager to be used when clustering.
   * <p>
   * Only valid if clustered = true.
   * <p>
   * Normally Vert.x will look on the classpath for a cluster manager, but if you want to set one
   * programmatically you can use this method.
   */
  setClusterManager(clusterManager: any /* io.vertx.core.spi.cluster.ClusterManager */): VertxOptions;

  /**
   * Sets the event bus configuration to configure the host, port, ssl...
   */
  getEventBusOptions(): EventBusOptions;

  /**
   * Sets the event bus configuration to configure the host, port, ssl...
   */
  setEventBusOptions(eventBusOptions: EventBusOptions): VertxOptions;

  /**
   * Set the number of event loop threads to be used by the Vert.x instance.
   */
  getEventLoopPoolSize(): number;

  /**
   * Set the number of event loop threads to be used by the Vert.x instance.
   */
  setEventLoopPoolSize(eventLoopPoolSize: number): VertxOptions;

  /**
   * Set the file system options
   */
  getFileSystemOptions(): FileSystemOptions;

  /**
   * Set the file system options
   */
  setFileSystemOptions(fileSystemOptions: FileSystemOptions): VertxOptions;

  /**
   * Set whether HA will be enabled on the Vert.x instance.
   */
  isHAEnabled(): boolean;

  /**
   * Set whether HA will be enabled on the Vert.x instance.
   */
  setHAEnabled(haEnabled: boolean): VertxOptions;

  /**
   * Set the HA group to be used when HA is enabled.
   */
  getHAGroup(): string;

  /**
   * Set the HA group to be used when HA is enabled.
   */
  setHAGroup(haGroup: string): VertxOptions;

  /**
   * Set the value of internal blocking pool size
   */
  getInternalBlockingPoolSize(): number;

  /**
   * Set the value of internal blocking pool size
   */
  setInternalBlockingPoolSize(internalBlockingPoolSize: number): VertxOptions;

  /**
   * Sets the value of max event loop execute time, in <a href="../../dataobjects.html#VertxOptions">#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit</a>is 
   */
  getMaxEventLoopExecuteTime(): number;

  /**
   * Sets the value of max event loop execute time, in <a href="../../dataobjects.html#VertxOptions">#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setMaxEventLoopExecuteTimeUnit maxEventLoopExecuteTimeUnit</a>is 
   */
  setMaxEventLoopExecuteTime(maxEventLoopExecuteTime: number): VertxOptions;

  /**
   * Set the time unit of <code>maxEventLoopExecuteTime</code>.
   */
  getMaxEventLoopExecuteTimeUnit(): any;

  /**
   * Set the time unit of <code>maxEventLoopExecuteTime</code>.
   */
  setMaxEventLoopExecuteTimeUnit(maxEventLoopExecuteTimeUnit: any): VertxOptions;

  /**
   * Sets the value of max worker execute time, in <a href="../../dataobjects.html#VertxOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a> is 
   */
  getMaxWorkerExecuteTime(): number;

  /**
   * Sets the value of max worker execute time, in <a href="../../dataobjects.html#VertxOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a>.
   * <p>
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setMaxWorkerExecuteTimeUnit maxWorkerExecuteTimeUnit</a> is 
   */
  setMaxWorkerExecuteTime(maxWorkerExecuteTime: number): VertxOptions;

  /**
   * Set the time unit of <code>maxWorkerExecuteTime</code>.
   */
  getMaxWorkerExecuteTimeUnit(): any;

  /**
   * Set the time unit of <code>maxWorkerExecuteTime</code>.
   */
  setMaxWorkerExecuteTimeUnit(maxWorkerExecuteTimeUnit: any): VertxOptions;

  /**
   * Set the metrics options
   */
  getMetricsOptions(): MetricsOptions;

  /**
   * Set the metrics options
   */
  setMetricsOptions(metricsOptions: MetricsOptions): VertxOptions;

  /**
   * Set wether to prefer the native transport to the JDK transport.
   */
  getPreferNativeTransport(): boolean;

  /**
   * Set wether to prefer the native transport to the JDK transport.
   */
  setPreferNativeTransport(preferNativeTransport: boolean): VertxOptions;

  /**
   * Set the quorum size to be used when HA is enabled.
   */
  getQuorumSize(): number;

  /**
   * Set the quorum size to be used when HA is enabled.
   */
  setQuorumSize(quorumSize: number): VertxOptions;

  getTracingOptions(): TracingOptions;

  setTracingOptions(tracingOptions: TracingOptions): VertxOptions;

  /**
   * Set the threshold value above this, the blocked warning contains a stack trace. in <a href="../../dataobjects.html#VertxOptions">#setWarningExceptionTimeUnit warningExceptionTimeUnit</a>.
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setWarningExceptionTimeUnit warningExceptionTimeUnit</a> is 
   */
  getWarningExceptionTime(): number;

  /**
   * Set the threshold value above this, the blocked warning contains a stack trace. in <a href="../../dataobjects.html#VertxOptions">#setWarningExceptionTimeUnit warningExceptionTimeUnit</a>.
   * The default value of <a href="../../dataobjects.html#VertxOptions">#setWarningExceptionTimeUnit warningExceptionTimeUnit</a> is 
   */
  setWarningExceptionTime(warningExceptionTime: number): VertxOptions;

  /**
   * Set the time unit of <code>warningExceptionTime</code>.
   */
  getWarningExceptionTimeUnit(): any;

  /**
   * Set the time unit of <code>warningExceptionTime</code>.
   */
  setWarningExceptionTimeUnit(warningExceptionTimeUnit: any): VertxOptions;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   */
  getWorkerPoolSize(): number;

  /**
   * Set the maximum number of worker threads to be used by the Vert.x instance.
   */
  setWorkerPoolSize(workerPoolSize: number): VertxOptions;

}

import { WebsocketVersion } from './enums';

/**
 * Options describing how an {@link HttpClient} connect a {@link WebSocket}.
 */
export class WebSocketConnectOptions {

  constructor();

  constructor(obj: WebSocketConnectOptions);

  /**
   * Parse an absolute URI to use, this will update the <code>ssl</code>, <code>host</code>,
   * <code>port</code> and <code>uri</code> fields.
   */
  setAbsoluteURI(absoluteURI: string): WebSocketConnectOptions;

  /**
   * Set whether to follow HTTP redirect
   */
  getFollowRedirects(): boolean;

  /**
   * Set whether to follow HTTP redirect
   */
  setFollowRedirects(followRedirects: boolean): WebSocketConnectOptions;

  /**
   * Add a request header.
   */
  addHeader(key: string, headers: string): WebSocketConnectOptions;

  /**
   * Set the host name to be used by the client request.
   */
  getHost(): string;

  /**
   * Set the host name to be used by the client request.
   */
  setHost(host: string): WebSocketConnectOptions;

  /**
   * Set the HTTP method to be used by the client request.
   */
  getMethod(): HttpMethod;

  /**
   * Set the HTTP method to be used by the client request.
   */
  setMethod(method: HttpMethod): WebSocketConnectOptions;

  /**
   * Set the port to be used by the client request.
   */
  getPort(): number;

  /**
   * Set the port to be used by the client request.
   */
  setPort(port: number): WebSocketConnectOptions;

  /**
   * Set the server address to be used by the client request.
   *
   * <p> When the server address is <code>null</code>, the address will be resolved after the <code>host</code>
   * property by the Vert.x resolver.
   *
   * <p> Use this when you want to connect to a specific server address without name resolution.
   */
  getServer(): SocketAddress;

  /**
   * Set the server address to be used by the client request.
   *
   * <p> When the server address is <code>null</code>, the address will be resolved after the <code>host</code>
   * property by the Vert.x resolver.
   *
   * <p> Use this when you want to connect to a specific server address without name resolution.
   */
  setServer(server: SocketAddress): WebSocketConnectOptions;

  /**
   * Set whether SSL/TLS is enabled.
   */
  isSsl(): boolean;

  /**
   * Set whether SSL/TLS is enabled.
   */
  setSsl(ssl: boolean): WebSocketConnectOptions;

  /**
   * Set the WebSocket sub protocols to use.
   */
  getSubProtocols(): string;

  /**
   * Set the WebSocket sub protocols to use.
   */
  setSubProtocols(subProtocols: string): WebSocketConnectOptions;

  /**
   * Set the WebSocket sub protocols to use.
   */
  addSubProtocol(subProtocols: string): WebSocketConnectOptions;

  /**
   * Sets the amount of time after which if the request does not return any data within the timeout period an
   * TimeoutException will be passed to the exception handler and
   * the request will be closed.
   */
  getTimeout(): number;

  /**
   * Sets the amount of time after which if the request does not return any data within the timeout period an
   * TimeoutException will be passed to the exception handler and
   * the request will be closed.
   */
  setTimeout(timeout: number): WebSocketConnectOptions;

  /**
   * Set the request relative URI.
   */
  getURI(): string;

  /**
   * Set the request relative URI.
   */
  setURI(uri: string): WebSocketConnectOptions;

  /**
   * Set the WebSocket version.
   */
  getVersion(): WebsocketVersion;

  /**
   * Set the WebSocket version.
   */
  setVersion(version: WebsocketVersion): WebSocketConnectOptions;

}
